// automatically generated by the FlatBuffers compiler, do not modify

extern crate flatbuffers;

use crate::cht::{commands::*, utils::*};
use flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Msg {
    NONE = 0,
    ApLoc = 1,
    CapAp = 2,
    CapPhy = 3,
    Command = 4,
    DelAp = 5,
    DelPhy = 6,
    DelRadio = 7,
    DelSta = 8,
    DelZone = 9,
    EndApply = 10,
    FileAck = 11,
    FileChunk = 12,
    FileStart = 13,
    InfoAca = 14,
    InfoChannel = 15,
    InfoIfaces = 16,
    InfoLb = 17,
    InfoPre = 18,
    InfoRadio = 19,
    InfoSr = 20,
    InfoSta = 21,
    InfoTc = 22,
    InfoZone = 23,
    ListStatSta = 24,
    MgrConn = 25,
    MgrDisc = 26,
    Response = 27,
}

const ENUM_MIN_MSG: u8 = 0;
const ENUM_MAX_MSG: u8 = 27;

impl<'a> flatbuffers::Follow<'a> for Msg {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for Msg {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const Msg;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const Msg;
        unsafe { *p }
    }
}

impl flatbuffers::Push for Msg {
    type Output = Msg;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Msg>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_MSG: [Msg; 28] = [
    Msg::NONE,
    Msg::ApLoc,
    Msg::CapAp,
    Msg::CapPhy,
    Msg::Command,
    Msg::DelAp,
    Msg::DelPhy,
    Msg::DelRadio,
    Msg::DelSta,
    Msg::DelZone,
    Msg::EndApply,
    Msg::FileAck,
    Msg::FileChunk,
    Msg::FileStart,
    Msg::InfoAca,
    Msg::InfoChannel,
    Msg::InfoIfaces,
    Msg::InfoLb,
    Msg::InfoPre,
    Msg::InfoRadio,
    Msg::InfoSr,
    Msg::InfoSta,
    Msg::InfoTc,
    Msg::InfoZone,
    Msg::ListStatSta,
    Msg::MgrConn,
    Msg::MgrDisc,
    Msg::Response,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_MSG: [&'static str; 28] = [
    "NONE",
    "ApLoc",
    "CapAp",
    "CapPhy",
    "Command",
    "DelAp",
    "DelPhy",
    "DelRadio",
    "DelSta",
    "DelZone",
    "EndApply",
    "FileAck",
    "FileChunk",
    "FileStart",
    "InfoAca",
    "InfoChannel",
    "InfoIfaces",
    "InfoLb",
    "InfoPre",
    "InfoRadio",
    "InfoSr",
    "InfoSta",
    "InfoTc",
    "InfoZone",
    "ListStatSta",
    "MgrConn",
    "MgrDisc",
    "Response",
];

pub fn enum_name_msg(e: Msg) -> &'static str {
    let index = e as u8;
    ENUM_NAMES_MSG[index as usize]
}

pub struct MsgUnionTableOffset {}
// struct MacAddress, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MacAddress {
    b0_: u8,
    b1_: u8,
    b2_: u8,
    b3_: u8,
    b4_: u8,
    b5_: u8,
} // pub struct MacAddress
impl flatbuffers::SafeSliceAccess for MacAddress {}
impl<'a> flatbuffers::Follow<'a> for MacAddress {
    type Inner = &'a MacAddress;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a MacAddress>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a MacAddress {
    type Inner = &'a MacAddress;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<MacAddress>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for MacAddress {
    type Output = MacAddress;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const MacAddress as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b MacAddress {
    type Output = MacAddress;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const MacAddress as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl MacAddress {
    pub fn new<'a>(_b0: u8, _b1: u8, _b2: u8, _b3: u8, _b4: u8, _b5: u8) -> Self {
        MacAddress {
            b0_: _b0.to_little_endian(),
            b1_: _b1.to_little_endian(),
            b2_: _b2.to_little_endian(),
            b3_: _b3.to_little_endian(),
            b4_: _b4.to_little_endian(),
            b5_: _b5.to_little_endian(),
        }
    }
    pub fn b0<'a>(&'a self) -> u8 {
        self.b0_.from_little_endian()
    }
    pub fn b1<'a>(&'a self) -> u8 {
        self.b1_.from_little_endian()
    }
    pub fn b2<'a>(&'a self) -> u8 {
        self.b2_.from_little_endian()
    }
    pub fn b3<'a>(&'a self) -> u8 {
        self.b3_.from_little_endian()
    }
    pub fn b4<'a>(&'a self) -> u8 {
        self.b4_.from_little_endian()
    }
    pub fn b5<'a>(&'a self) -> u8 {
        self.b5_.from_little_endian()
    }
}

// struct Version, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Version {
    major_: u8,
    minor_: u8,
    patch_: u8,
} // pub struct Version
impl flatbuffers::SafeSliceAccess for Version {}
impl<'a> flatbuffers::Follow<'a> for Version {
    type Inner = &'a Version;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Version>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Version {
    type Inner = &'a Version;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Version>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Version {
    type Output = Version;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Version as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Version {
    type Output = Version;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Version as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl Version {
    pub fn new<'a>(_major: u8, _minor: u8, _patch: u8) -> Self {
        Version {
            major_: _major.to_little_endian(),
            minor_: _minor.to_little_endian(),
            patch_: _patch.to_little_endian(),
        }
    }
    pub fn major<'a>(&'a self) -> u8 {
        self.major_.from_little_endian()
    }
    pub fn minor<'a>(&'a self) -> u8 {
        self.minor_.from_little_endian()
    }
    pub fn patch<'a>(&'a self) -> u8 {
        self.patch_.from_little_endian()
    }
}

pub enum ContainerOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Container<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Container<'a> {
    type Inner = Container<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Container<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Container { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ContainerArgs,
    ) -> flatbuffers::WIPOffset<Container<'bldr>> {
        let mut builder = ContainerBuilder::new(_fbb);
        if let Some(x) = args.msg {
            builder.add_msg(x);
        }
        builder.add_msg_type(args.msg_type);
        builder.finish()
    }

    pub const VT_MSG_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MSG: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn msg_type(&self) -> Msg {
        self._tab
            .get::<Msg>(Container::VT_MSG_TYPE, Some(Msg::NONE))
            .unwrap()
    }
    #[inline]
    pub fn msg(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Container::VT_MSG, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_ap_loc(&self) -> Option<ApLoc<'a>> {
        if self.msg_type() == Msg::ApLoc {
            self.msg().map(|u| ApLoc::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_cap_ap(&self) -> Option<CapAp<'a>> {
        if self.msg_type() == Msg::CapAp {
            self.msg().map(|u| CapAp::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_cap_phy(&self) -> Option<CapPhy<'a>> {
        if self.msg_type() == Msg::CapPhy {
            self.msg().map(|u| CapPhy::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_command(&self) -> Option<Command<'a>> {
        if self.msg_type() == Msg::Command {
            self.msg().map(|u| Command::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_del_ap(&self) -> Option<DelAp<'a>> {
        if self.msg_type() == Msg::DelAp {
            self.msg().map(|u| DelAp::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_del_phy(&self) -> Option<DelPhy<'a>> {
        if self.msg_type() == Msg::DelPhy {
            self.msg().map(|u| DelPhy::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_del_radio(&self) -> Option<DelRadio<'a>> {
        if self.msg_type() == Msg::DelRadio {
            self.msg().map(|u| DelRadio::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_del_sta(&self) -> Option<DelSta<'a>> {
        if self.msg_type() == Msg::DelSta {
            self.msg().map(|u| DelSta::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_del_zone(&self) -> Option<DelZone<'a>> {
        if self.msg_type() == Msg::DelZone {
            self.msg().map(|u| DelZone::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_end_apply(&self) -> Option<EndApply<'a>> {
        if self.msg_type() == Msg::EndApply {
            self.msg().map(|u| EndApply::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_file_ack(&self) -> Option<FileAck<'a>> {
        if self.msg_type() == Msg::FileAck {
            self.msg().map(|u| FileAck::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_file_chunk(&self) -> Option<FileChunk<'a>> {
        if self.msg_type() == Msg::FileChunk {
            self.msg().map(|u| FileChunk::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_file_start(&self) -> Option<FileStart<'a>> {
        if self.msg_type() == Msg::FileStart {
            self.msg().map(|u| FileStart::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_aca(&self) -> Option<InfoAca<'a>> {
        if self.msg_type() == Msg::InfoAca {
            self.msg().map(|u| InfoAca::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_channel(&self) -> Option<InfoChannel<'a>> {
        if self.msg_type() == Msg::InfoChannel {
            self.msg().map(|u| InfoChannel::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_ifaces(&self) -> Option<InfoIfaces<'a>> {
        if self.msg_type() == Msg::InfoIfaces {
            self.msg().map(|u| InfoIfaces::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_lb(&self) -> Option<InfoLb<'a>> {
        if self.msg_type() == Msg::InfoLb {
            self.msg().map(|u| InfoLb::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_pre(&self) -> Option<InfoPre<'a>> {
        if self.msg_type() == Msg::InfoPre {
            self.msg().map(|u| InfoPre::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_radio(&self) -> Option<InfoRadio<'a>> {
        if self.msg_type() == Msg::InfoRadio {
            self.msg().map(|u| InfoRadio::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_sr(&self) -> Option<InfoSr<'a>> {
        if self.msg_type() == Msg::InfoSr {
            self.msg().map(|u| InfoSr::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_sta(&self) -> Option<InfoSta<'a>> {
        if self.msg_type() == Msg::InfoSta {
            self.msg().map(|u| InfoSta::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_tc(&self) -> Option<InfoTc<'a>> {
        if self.msg_type() == Msg::InfoTc {
            self.msg().map(|u| InfoTc::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_info_zone(&self) -> Option<InfoZone<'a>> {
        if self.msg_type() == Msg::InfoZone {
            self.msg().map(|u| InfoZone::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_list_stat_sta(&self) -> Option<ListStatSta<'a>> {
        if self.msg_type() == Msg::ListStatSta {
            self.msg().map(|u| ListStatSta::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_mgr_conn(&self) -> Option<MgrConn<'a>> {
        if self.msg_type() == Msg::MgrConn {
            self.msg().map(|u| MgrConn::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_mgr_disc(&self) -> Option<MgrDisc<'a>> {
        if self.msg_type() == Msg::MgrDisc {
            self.msg().map(|u| MgrDisc::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn msg_as_response(&self) -> Option<Response<'a>> {
        if self.msg_type() == Msg::Response {
            self.msg().map(|u| Response::init_from_table(u))
        } else {
            None
        }
    }
}

pub struct ContainerArgs {
    pub msg_type: Msg,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ContainerArgs {
    #[inline]
    fn default() -> Self {
        ContainerArgs {
            msg_type: Msg::NONE,
            msg: None,
        }
    }
}
pub struct ContainerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContainerBuilder<'a, 'b> {
    #[inline]
    pub fn add_msg_type(&mut self, msg_type: Msg) {
        self.fbb_
            .push_slot::<Msg>(Container::VT_MSG_TYPE, msg_type, Msg::NONE);
    }
    #[inline]
    pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Container::VT_MSG, msg);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContainerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ContainerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Container<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum ApLocOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ApLoc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ApLoc<'a> {
    type Inner = ApLoc<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ApLoc<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ApLoc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ApLocArgs<'args>,
    ) -> flatbuffers::WIPOffset<ApLoc<'bldr>> {
        let mut builder = ApLocBuilder::new(_fbb);
        builder.add_g(args.g);
        if let Some(x) = args.loc {
            builder.add_loc(x);
        }
        builder.add_src(args.src);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_LOC: flatbuffers::VOffsetT = 6;
    pub const VT_G: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(ApLoc::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn loc(&self) -> Option<&'a Loc3Float> {
        self._tab.get::<Loc3Float>(ApLoc::VT_LOC, None)
    }
    #[inline]
    pub fn g(&self) -> u64 {
        self._tab.get::<u64>(ApLoc::VT_G, Some(0)).unwrap()
    }
}

pub struct ApLocArgs<'a> {
    pub src: u32,
    pub loc: Option<&'a Loc3Float>,
    pub g: u64,
}
impl<'a> Default for ApLocArgs<'a> {
    #[inline]
    fn default() -> Self {
        ApLocArgs {
            src: 0,
            loc: None,
            g: 0,
        }
    }
}
pub struct ApLocBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ApLocBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(ApLoc::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_loc(&mut self, loc: &'b Loc3Float) {
        self.fbb_.push_slot_always::<&Loc3Float>(ApLoc::VT_LOC, loc);
    }
    #[inline]
    pub fn add_g(&mut self, g: u64) {
        self.fbb_.push_slot::<u64>(ApLoc::VT_G, g, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ApLocBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ApLocBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ApLoc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum CapApOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CapAp<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CapAp<'a> {
    type Inner = CapAp<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CapAp<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CapAp { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CapApArgs<'args>,
    ) -> flatbuffers::WIPOffset<CapAp<'bldr>> {
        let mut builder = CapApBuilder::new(_fbb);
        builder.add_uptime(args.uptime);
        if let Some(x) = args.ecoversion {
            builder.add_ecoversion(x);
        }
        if let Some(x) = args.model {
            builder.add_model(x);
        }
        if let Some(x) = args.modules {
            builder.add_modules(x);
        }
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        if let Some(x) = args.serial_number {
            builder.add_serial_number(x);
        }
        builder.add_src(args.src);
        builder.add_cht_port(args.cht_port);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_CHT_PORT: flatbuffers::VOffsetT = 6;
    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 8;
    pub const VT_MAC: flatbuffers::VOffsetT = 10;
    pub const VT_MODULES: flatbuffers::VOffsetT = 12;
    pub const VT_MODEL: flatbuffers::VOffsetT = 14;
    pub const VT_ECOVERSION: flatbuffers::VOffsetT = 16;
    pub const VT_UPTIME: flatbuffers::VOffsetT = 18;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(CapAp::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn cht_port(&self) -> u16 {
        self._tab
            .get::<u16>(CapAp::VT_CHT_PORT, Some(40000))
            .unwrap()
    }
    #[inline]
    pub fn serial_number(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CapAp::VT_SERIAL_NUMBER, None)
    }
    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(CapAp::VT_MAC, None)
    }
    #[inline]
    pub fn modules(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Module<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Module<'a>>>,
        >>(CapAp::VT_MODULES, None)
    }
    #[inline]
    pub fn model(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CapAp::VT_MODEL, None)
    }
    #[inline]
    pub fn ecoversion(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CapAp::VT_ECOVERSION, None)
    }
    #[inline]
    pub fn uptime(&self) -> u64 {
        self._tab.get::<u64>(CapAp::VT_UPTIME, Some(0)).unwrap()
    }
}

pub struct CapApArgs<'a> {
    pub src: u32,
    pub cht_port: u16,
    pub serial_number: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mac: Option<&'a MacAddress>,
    pub modules: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Module<'a>>>>,
    >,
    pub model: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ecoversion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uptime: u64,
}
impl<'a> Default for CapApArgs<'a> {
    #[inline]
    fn default() -> Self {
        CapApArgs {
            src: 0,
            cht_port: 40000,
            serial_number: None,
            mac: None,
            modules: None,
            model: None,
            ecoversion: None,
            uptime: 0,
        }
    }
}
pub struct CapApBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CapApBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(CapAp::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_cht_port(&mut self, cht_port: u16) {
        self.fbb_
            .push_slot::<u16>(CapAp::VT_CHT_PORT, cht_port, 40000);
    }
    #[inline]
    pub fn add_serial_number(&mut self, serial_number: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapAp::VT_SERIAL_NUMBER, serial_number);
    }
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(CapAp::VT_MAC, mac);
    }
    #[inline]
    pub fn add_modules(
        &mut self,
        modules: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Module<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapAp::VT_MODULES, modules);
    }
    #[inline]
    pub fn add_model(&mut self, model: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapAp::VT_MODEL, model);
    }
    #[inline]
    pub fn add_ecoversion(&mut self, ecoversion: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapAp::VT_ECOVERSION, ecoversion);
    }
    #[inline]
    pub fn add_uptime(&mut self, uptime: u64) {
        self.fbb_.push_slot::<u64>(CapAp::VT_UPTIME, uptime, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CapApBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CapApBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CapAp<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum CapPhyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CapPhy<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CapPhy<'a> {
    type Inner = CapPhy<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CapPhy<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CapPhy { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CapPhyArgs<'args>,
    ) -> flatbuffers::WIPOffset<CapPhy<'bldr>> {
        let mut builder = CapPhyBuilder::new(_fbb);
        if let Some(x) = args.curr_ht_mode {
            builder.add_curr_ht_mode(x);
        }
        if let Some(x) = args.conf_ht_mode {
            builder.add_conf_ht_mode(x);
        }
        if let Some(x) = args.powers {
            builder.add_powers(x);
        }
        if let Some(x) = args.bands {
            builder.add_bands(x);
        }
        if let Some(x) = args.uci_name {
            builder.add_uci_name(x);
        }
        if let Some(x) = args.phy_name {
            builder.add_phy_name(x);
        }
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        builder.add_src(args.src);
        builder.add_curr_channel(args.curr_channel);
        builder.add_curr_tx_power(args.curr_tx_power);
        builder.add_state(args.state);
        builder.add_conf_disable_b(args.conf_disable_b);
        builder.add_conf_channel(args.conf_channel);
        builder.add_conf_band(args.conf_band);
        builder.add_conf_tx_power(args.conf_tx_power);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_PHY_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_UCI_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_BANDS: flatbuffers::VOffsetT = 12;
    pub const VT_POWERS: flatbuffers::VOffsetT = 14;
    pub const VT_CONF_TX_POWER: flatbuffers::VOffsetT = 16;
    pub const VT_CONF_BAND: flatbuffers::VOffsetT = 18;
    pub const VT_CONF_CHANNEL: flatbuffers::VOffsetT = 20;
    pub const VT_CONF_HT_MODE: flatbuffers::VOffsetT = 22;
    pub const VT_CONF_DISABLE_B: flatbuffers::VOffsetT = 24;
    pub const VT_STATE: flatbuffers::VOffsetT = 26;
    pub const VT_CURR_TX_POWER: flatbuffers::VOffsetT = 28;
    pub const VT_CURR_CHANNEL: flatbuffers::VOffsetT = 30;
    pub const VT_CURR_HT_MODE: flatbuffers::VOffsetT = 32;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(CapPhy::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(CapPhy::VT_MAC, None)
    }
    #[inline]
    pub fn phy_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CapPhy::VT_PHY_NAME, None)
    }
    #[inline]
    pub fn uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CapPhy::VT_UCI_NAME, None)
    }
    #[inline]
    pub fn bands(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Band<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Band<'a>>>,
        >>(CapPhy::VT_BANDS, None)
    }
    #[inline]
    pub fn powers(&self) -> Option<&'a [i8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                CapPhy::VT_POWERS,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn conf_tx_power(&self) -> i8 {
        self._tab
            .get::<i8>(CapPhy::VT_CONF_TX_POWER, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn conf_band(&self) -> u8 {
        self._tab.get::<u8>(CapPhy::VT_CONF_BAND, Some(0)).unwrap()
    }
    #[inline]
    pub fn conf_channel(&self) -> u8 {
        self._tab
            .get::<u8>(CapPhy::VT_CONF_CHANNEL, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn conf_ht_mode(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CapPhy::VT_CONF_HT_MODE, None)
    }
    #[inline]
    pub fn conf_disable_b(&self) -> u8 {
        self._tab
            .get::<u8>(CapPhy::VT_CONF_DISABLE_B, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn state(&self) -> u8 {
        self._tab.get::<u8>(CapPhy::VT_STATE, Some(0)).unwrap()
    }
    #[inline]
    pub fn curr_tx_power(&self) -> i8 {
        self._tab
            .get::<i8>(CapPhy::VT_CURR_TX_POWER, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn curr_channel(&self) -> u8 {
        self._tab
            .get::<u8>(CapPhy::VT_CURR_CHANNEL, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn curr_ht_mode(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CapPhy::VT_CURR_HT_MODE, None)
    }
}

pub struct CapPhyArgs<'a> {
    pub src: u32,
    pub mac: Option<&'a MacAddress>,
    pub phy_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bands: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Band<'a>>>>,
    >,
    pub powers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
    pub conf_tx_power: i8,
    pub conf_band: u8,
    pub conf_channel: u8,
    pub conf_ht_mode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub conf_disable_b: u8,
    pub state: u8,
    pub curr_tx_power: i8,
    pub curr_channel: u8,
    pub curr_ht_mode: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CapPhyArgs<'a> {
    #[inline]
    fn default() -> Self {
        CapPhyArgs {
            src: 0,
            mac: None,
            phy_name: None,
            uci_name: None,
            bands: None,
            powers: None,
            conf_tx_power: 0,
            conf_band: 0,
            conf_channel: 0,
            conf_ht_mode: None,
            conf_disable_b: 0,
            state: 0,
            curr_tx_power: 0,
            curr_channel: 0,
            curr_ht_mode: None,
        }
    }
}
pub struct CapPhyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CapPhyBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(CapPhy::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(CapPhy::VT_MAC, mac);
    }
    #[inline]
    pub fn add_phy_name(&mut self, phy_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapPhy::VT_PHY_NAME, phy_name);
    }
    #[inline]
    pub fn add_uci_name(&mut self, uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapPhy::VT_UCI_NAME, uci_name);
    }
    #[inline]
    pub fn add_bands(
        &mut self,
        bands: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Band<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapPhy::VT_BANDS, bands);
    }
    #[inline]
    pub fn add_powers(&mut self, powers: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapPhy::VT_POWERS, powers);
    }
    #[inline]
    pub fn add_conf_tx_power(&mut self, conf_tx_power: i8) {
        self.fbb_
            .push_slot::<i8>(CapPhy::VT_CONF_TX_POWER, conf_tx_power, 0);
    }
    #[inline]
    pub fn add_conf_band(&mut self, conf_band: u8) {
        self.fbb_
            .push_slot::<u8>(CapPhy::VT_CONF_BAND, conf_band, 0);
    }
    #[inline]
    pub fn add_conf_channel(&mut self, conf_channel: u8) {
        self.fbb_
            .push_slot::<u8>(CapPhy::VT_CONF_CHANNEL, conf_channel, 0);
    }
    #[inline]
    pub fn add_conf_ht_mode(&mut self, conf_ht_mode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapPhy::VT_CONF_HT_MODE, conf_ht_mode);
    }
    #[inline]
    pub fn add_conf_disable_b(&mut self, conf_disable_b: u8) {
        self.fbb_
            .push_slot::<u8>(CapPhy::VT_CONF_DISABLE_B, conf_disable_b, 0);
    }
    #[inline]
    pub fn add_state(&mut self, state: u8) {
        self.fbb_.push_slot::<u8>(CapPhy::VT_STATE, state, 0);
    }
    #[inline]
    pub fn add_curr_tx_power(&mut self, curr_tx_power: i8) {
        self.fbb_
            .push_slot::<i8>(CapPhy::VT_CURR_TX_POWER, curr_tx_power, 0);
    }
    #[inline]
    pub fn add_curr_channel(&mut self, curr_channel: u8) {
        self.fbb_
            .push_slot::<u8>(CapPhy::VT_CURR_CHANNEL, curr_channel, 0);
    }
    #[inline]
    pub fn add_curr_ht_mode(&mut self, curr_ht_mode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CapPhy::VT_CURR_HT_MODE, curr_ht_mode);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CapPhyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CapPhyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CapPhy<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum CommandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Command<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Command<'a> {
    type Inner = Command<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Command<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Command { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CommandArgs,
    ) -> flatbuffers::WIPOffset<Command<'bldr>> {
        let mut builder = CommandBuilder::new(_fbb);
        builder.add_id(args.id);
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        builder.add_src(args.src);
        builder.add_command_type(args.command_type);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SRC: flatbuffers::VOffsetT = 6;
    pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn id(&self) -> u64 {
        self._tab.get::<u64>(Command::VT_ID, Some(0)).unwrap()
    }
    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(Command::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn command_type(&self) -> CmdType {
        self._tab
            .get::<CmdType>(Command::VT_COMMAND_TYPE, Some(CmdType::NONE))
            .unwrap()
    }
    #[inline]
    pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Command::VT_COMMAND, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_add_to_cht_zone(&self) -> Option<AddToChtZone<'a>> {
        if self.command_type() == CmdType::AddToChtZone {
            self.command().map(|u| AddToChtZone::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_aca_disable(&self) -> Option<AcaDisable<'a>> {
        if self.command_type() == CmdType::AcaDisable {
            self.command().map(|u| AcaDisable::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_aca_enable(&self) -> Option<AcaEnable<'a>> {
        if self.command_type() == CmdType::AcaEnable {
            self.command().map(|u| AcaEnable::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_ap_info(&self) -> Option<ApInfo<'a>> {
        if self.command_type() == CmdType::ApInfo {
            self.command().map(|u| ApInfo::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_apply(&self) -> Option<Apply<'a>> {
        if self.command_type() == CmdType::Apply {
            self.command().map(|u| Apply::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_backup(&self) -> Option<Backup<'a>> {
        if self.command_type() == CmdType::Backup {
            self.command().map(|u| Backup::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_create_vlan(&self) -> Option<CreateVlan<'a>> {
        if self.command_type() == CmdType::CreateVlan {
            self.command().map(|u| CreateVlan::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_create_vradio(&self) -> Option<CreateVradio<'a>> {
        if self.command_type() == CmdType::CreateVradio {
            self.command().map(|u| CreateVradio::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_disable_radio(&self) -> Option<DisableRadio<'a>> {
        if self.command_type() == CmdType::DisableRadio {
            self.command().map(|u| DisableRadio::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_enable_radio(&self) -> Option<EnableRadio<'a>> {
        if self.command_type() == CmdType::EnableRadio {
            self.command().map(|u| EnableRadio::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_flash(&self) -> Option<Flash<'a>> {
        if self.command_type() == CmdType::Flash {
            self.command().map(|u| Flash::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_loc_remove_my_pos(&self) -> Option<LocRemoveMyPos<'a>> {
        if self.command_type() == CmdType::LocRemoveMyPos {
            self.command().map(|u| LocRemoveMyPos::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_loc_set_my_pos(&self) -> Option<LocSetMyPos<'a>> {
        if self.command_type() == CmdType::LocSetMyPos {
            self.command().map(|u| LocSetMyPos::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_reboot(&self) -> Option<Reboot<'a>> {
        if self.command_type() == CmdType::Reboot {
            self.command().map(|u| Reboot::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_remove_from_cht_zone(&self) -> Option<RemoveFromChtZone<'a>> {
        if self.command_type() == CmdType::RemoveFromChtZone {
            self.command()
                .map(|u| RemoveFromChtZone::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_remove_vlan(&self) -> Option<RemoveVlan<'a>> {
        if self.command_type() == CmdType::RemoveVlan {
            self.command().map(|u| RemoveVlan::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_remove_vradio(&self) -> Option<RemoveVradio<'a>> {
        if self.command_type() == CmdType::RemoveVradio {
            self.command().map(|u| RemoveVradio::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_restore(&self) -> Option<Restore<'a>> {
        if self.command_type() == CmdType::Restore {
            self.command().map(|u| Restore::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_set_channel(&self) -> Option<SetChannel<'a>> {
        if self.command_type() == CmdType::SetChannel {
            self.command().map(|u| SetChannel::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_set_op_mode(&self) -> Option<SetOpMode<'a>> {
        if self.command_type() == CmdType::SetOpMode {
            self.command().map(|u| SetOpMode::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_set_power(&self) -> Option<SetPower<'a>> {
        if self.command_type() == CmdType::SetPower {
            self.command().map(|u| SetPower::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_set_report_crashes(&self) -> Option<SetReportCrashes<'a>> {
        if self.command_type() == CmdType::SetReportCrashes {
            self.command().map(|u| SetReportCrashes::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_tc_disable(&self) -> Option<TcDisable<'a>> {
        if self.command_type() == CmdType::TcDisable {
            self.command().map(|u| TcDisable::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_tc_enable(&self) -> Option<TcEnable<'a>> {
        if self.command_type() == CmdType::TcEnable {
            self.command().map(|u| TcEnable::init_from_table(u))
        } else {
            None
        }
    }
}

pub struct CommandArgs {
    pub id: u64,
    pub src: u32,
    pub command_type: CmdType,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CommandArgs {
    #[inline]
    fn default() -> Self {
        CommandArgs {
            id: 0,
            src: 0,
            command_type: CmdType::NONE,
            command: None,
        }
    }
}
pub struct CommandBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CommandBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: u64) {
        self.fbb_.push_slot::<u64>(Command::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(Command::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_command_type(&mut self, command_type: CmdType) {
        self.fbb_
            .push_slot::<CmdType>(Command::VT_COMMAND_TYPE, command_type, CmdType::NONE);
    }
    #[inline]
    pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Command::VT_COMMAND, command);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommandBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CommandBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Command<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum DelApOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DelAp<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelAp<'a> {
    type Inner = DelAp<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DelAp<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DelAp { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DelApArgs,
    ) -> flatbuffers::WIPOffset<DelAp<'bldr>> {
        let mut builder = DelApBuilder::new(_fbb);
        builder.add_src(args.src);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(DelAp::VT_SRC, Some(0)).unwrap()
    }
}

pub struct DelApArgs {
    pub src: u32,
}
impl<'a> Default for DelApArgs {
    #[inline]
    fn default() -> Self {
        DelApArgs { src: 0 }
    }
}
pub struct DelApBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelApBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(DelAp::VT_SRC, src, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelApBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DelApBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DelAp<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum DelPhyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DelPhy<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelPhy<'a> {
    type Inner = DelPhy<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DelPhy<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DelPhy { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DelPhyArgs<'args>,
    ) -> flatbuffers::WIPOffset<DelPhy<'bldr>> {
        let mut builder = DelPhyBuilder::new(_fbb);
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        builder.add_src(args.src);
        builder.add_state(args.state);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_STATE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(DelPhy::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(DelPhy::VT_MAC, None)
    }
    #[inline]
    pub fn state(&self) -> u8 {
        self._tab.get::<u8>(DelPhy::VT_STATE, Some(0)).unwrap()
    }
}

pub struct DelPhyArgs<'a> {
    pub src: u32,
    pub mac: Option<&'a MacAddress>,
    pub state: u8,
}
impl<'a> Default for DelPhyArgs<'a> {
    #[inline]
    fn default() -> Self {
        DelPhyArgs {
            src: 0,
            mac: None,
            state: 0,
        }
    }
}
pub struct DelPhyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelPhyBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(DelPhy::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(DelPhy::VT_MAC, mac);
    }
    #[inline]
    pub fn add_state(&mut self, state: u8) {
        self.fbb_.push_slot::<u8>(DelPhy::VT_STATE, state, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelPhyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DelPhyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DelPhy<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum DelRadioOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DelRadio<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelRadio<'a> {
    type Inner = DelRadio<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DelRadio<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DelRadio { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DelRadioArgs<'args>,
    ) -> flatbuffers::WIPOffset<DelRadio<'bldr>> {
        let mut builder = DelRadioBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        builder.add_src(args.src);
        builder.add_is_in_config(args.is_in_config);
        builder.add_state(args.state);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_SSID: flatbuffers::VOffsetT = 8;
    pub const VT_STATE: flatbuffers::VOffsetT = 10;
    pub const VT_IS_IN_CONFIG: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(DelRadio::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(DelRadio::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(DelRadio::VT_SSID, None)
    }
    #[inline]
    pub fn state(&self) -> u8 {
        self._tab.get::<u8>(DelRadio::VT_STATE, Some(0)).unwrap()
    }
    #[inline]
    pub fn is_in_config(&self) -> u8 {
        self._tab
            .get::<u8>(DelRadio::VT_IS_IN_CONFIG, Some(0))
            .unwrap()
    }
}

pub struct DelRadioArgs<'a> {
    pub src: u32,
    pub phy_mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub state: u8,
    pub is_in_config: u8,
}
impl<'a> Default for DelRadioArgs<'a> {
    #[inline]
    fn default() -> Self {
        DelRadioArgs {
            src: 0,
            phy_mac: None,
            ssid: None,
            state: 0,
            is_in_config: 0,
        }
    }
}
pub struct DelRadioBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelRadioBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(DelRadio::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(DelRadio::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DelRadio::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_state(&mut self, state: u8) {
        self.fbb_.push_slot::<u8>(DelRadio::VT_STATE, state, 0);
    }
    #[inline]
    pub fn add_is_in_config(&mut self, is_in_config: u8) {
        self.fbb_
            .push_slot::<u8>(DelRadio::VT_IS_IN_CONFIG, is_in_config, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelRadioBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DelRadioBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DelRadio<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum DelStaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DelSta<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelSta<'a> {
    type Inner = DelSta<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DelSta<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DelSta { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DelStaArgs<'args>,
    ) -> flatbuffers::WIPOffset<DelSta<'bldr>> {
        let mut builder = DelStaBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        builder.add_src(args.src);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 8;
    pub const VT_SSID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(DelSta::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(DelSta::VT_MAC, None)
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(DelSta::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(DelSta::VT_SSID, None)
    }
}

pub struct DelStaArgs<'a> {
    pub src: u32,
    pub mac: Option<&'a MacAddress>,
    pub phy_mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DelStaArgs<'a> {
    #[inline]
    fn default() -> Self {
        DelStaArgs {
            src: 0,
            mac: None,
            phy_mac: None,
            ssid: None,
        }
    }
}
pub struct DelStaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelStaBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(DelSta::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(DelSta::VT_MAC, mac);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(DelSta::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DelSta::VT_SSID, ssid);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelStaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DelStaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DelSta<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum DelZoneOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DelZone<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelZone<'a> {
    type Inner = DelZone<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DelZone<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DelZone { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DelZoneArgs,
    ) -> flatbuffers::WIPOffset<DelZone<'bldr>> {
        let mut builder = DelZoneBuilder::new(_fbb);
        builder.add_ip(args.ip);
        builder.add_src(args.src);
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_IP: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(DelZone::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn ip(&self) -> u32 {
        self._tab.get::<u32>(DelZone::VT_IP, Some(0)).unwrap()
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        self._tab.get::<u8>(DelZone::VT_TYPE_, Some(2)).unwrap()
    }
}

pub struct DelZoneArgs {
    pub src: u32,
    pub ip: u32,
    pub type_: u8,
}
impl<'a> Default for DelZoneArgs {
    #[inline]
    fn default() -> Self {
        DelZoneArgs {
            src: 0,
            ip: 0,
            type_: 2,
        }
    }
}
pub struct DelZoneBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelZoneBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(DelZone::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_ip(&mut self, ip: u32) {
        self.fbb_.push_slot::<u32>(DelZone::VT_IP, ip, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: u8) {
        self.fbb_.push_slot::<u8>(DelZone::VT_TYPE_, type_, 2);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelZoneBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DelZoneBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DelZone<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EndApplyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EndApply<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EndApply<'a> {
    type Inner = EndApply<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EndApply<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EndApply { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EndApplyArgs,
    ) -> flatbuffers::WIPOffset<EndApply<'bldr>> {
        let mut builder = EndApplyBuilder::new(_fbb);
        builder.add_src(args.src);
        builder.add_success(args.success);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_SUCCESS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(EndApply::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn success(&self) -> u8 {
        self._tab.get::<u8>(EndApply::VT_SUCCESS, Some(1)).unwrap()
    }
}

pub struct EndApplyArgs {
    pub src: u32,
    pub success: u8,
}
impl<'a> Default for EndApplyArgs {
    #[inline]
    fn default() -> Self {
        EndApplyArgs { src: 0, success: 1 }
    }
}
pub struct EndApplyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EndApplyBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(EndApply::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_success(&mut self, success: u8) {
        self.fbb_.push_slot::<u8>(EndApply::VT_SUCCESS, success, 1);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EndApplyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EndApplyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EndApply<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum FileAckOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FileAck<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileAck<'a> {
    type Inner = FileAck<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FileAck<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FileAck { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FileAckArgs,
    ) -> flatbuffers::WIPOffset<FileAck<'bldr>> {
        let mut builder = FileAckBuilder::new(_fbb);
        builder.add_src(args.src);
        builder.add_file_id(args.file_id);
        builder.add_error(args.error);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
    pub const VT_ERROR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(FileAck::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn file_id(&self) -> u16 {
        self._tab.get::<u16>(FileAck::VT_FILE_ID, Some(0)).unwrap()
    }
    #[inline]
    pub fn error(&self) -> u8 {
        self._tab.get::<u8>(FileAck::VT_ERROR, Some(0)).unwrap()
    }
}

pub struct FileAckArgs {
    pub src: u32,
    pub file_id: u16,
    pub error: u8,
}
impl<'a> Default for FileAckArgs {
    #[inline]
    fn default() -> Self {
        FileAckArgs {
            src: 0,
            file_id: 0,
            error: 0,
        }
    }
}
pub struct FileAckBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FileAckBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(FileAck::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_file_id(&mut self, file_id: u16) {
        self.fbb_.push_slot::<u16>(FileAck::VT_FILE_ID, file_id, 0);
    }
    #[inline]
    pub fn add_error(&mut self, error: u8) {
        self.fbb_.push_slot::<u8>(FileAck::VT_ERROR, error, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileAckBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FileAckBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FileAck<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum FileChunkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FileChunk<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileChunk<'a> {
    type Inner = FileChunk<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FileChunk<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FileChunk { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FileChunkArgs<'args>,
    ) -> flatbuffers::WIPOffset<FileChunk<'bldr>> {
        let mut builder = FileChunkBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.add_src(args.src);
        builder.add_file_id(args.file_id);
        builder.add_flag_end(args.flag_end);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
    pub const VT_FLAG_END: flatbuffers::VOffsetT = 8;
    pub const VT_DATA: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(FileChunk::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn file_id(&self) -> u16 {
        self._tab
            .get::<u16>(FileChunk::VT_FILE_ID, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn flag_end(&self) -> u8 {
        self._tab
            .get::<u8>(FileChunk::VT_FLAG_END, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> Option<&'a [i8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                FileChunk::VT_DATA,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct FileChunkArgs<'a> {
    pub src: u32,
    pub file_id: u16,
    pub flag_end: u8,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for FileChunkArgs<'a> {
    #[inline]
    fn default() -> Self {
        FileChunkArgs {
            src: 0,
            file_id: 0,
            flag_end: 0,
            data: None,
        }
    }
}
pub struct FileChunkBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FileChunkBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(FileChunk::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_file_id(&mut self, file_id: u16) {
        self.fbb_
            .push_slot::<u16>(FileChunk::VT_FILE_ID, file_id, 0);
    }
    #[inline]
    pub fn add_flag_end(&mut self, flag_end: u8) {
        self.fbb_
            .push_slot::<u8>(FileChunk::VT_FLAG_END, flag_end, 0);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FileChunk::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileChunkBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FileChunkBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FileChunk<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum FileStartOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FileStart<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileStart<'a> {
    type Inner = FileStart<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FileStart<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FileStart { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FileStartArgs<'args>,
    ) -> flatbuffers::WIPOffset<FileStart<'bldr>> {
        let mut builder = FileStartBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.md5 {
            builder.add_md5(x);
        }
        builder.add_src(args.src);
        builder.add_file_id(args.file_id);
        builder.add_flag_end(args.flag_end);
        builder.add_file_type(args.file_type);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
    pub const VT_FILE_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_MD5: flatbuffers::VOffsetT = 10;
    pub const VT_FLAG_END: flatbuffers::VOffsetT = 12;
    pub const VT_DATA: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(FileStart::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn file_id(&self) -> u16 {
        self._tab
            .get::<u16>(FileStart::VT_FILE_ID, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn file_type(&self) -> u8 {
        self._tab
            .get::<u8>(FileStart::VT_FILE_TYPE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn md5(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(FileStart::VT_MD5, None)
    }
    #[inline]
    pub fn flag_end(&self) -> u8 {
        self._tab
            .get::<u8>(FileStart::VT_FLAG_END, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> Option<&'a [i8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                FileStart::VT_DATA,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct FileStartArgs<'a> {
    pub src: u32,
    pub file_id: u16,
    pub file_type: u8,
    pub md5: Option<flatbuffers::WIPOffset<&'a str>>,
    pub flag_end: u8,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for FileStartArgs<'a> {
    #[inline]
    fn default() -> Self {
        FileStartArgs {
            src: 0,
            file_id: 0,
            file_type: 0,
            md5: None,
            flag_end: 0,
            data: None,
        }
    }
}
pub struct FileStartBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FileStartBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(FileStart::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_file_id(&mut self, file_id: u16) {
        self.fbb_
            .push_slot::<u16>(FileStart::VT_FILE_ID, file_id, 0);
    }
    #[inline]
    pub fn add_file_type(&mut self, file_type: u8) {
        self.fbb_
            .push_slot::<u8>(FileStart::VT_FILE_TYPE, file_type, 0);
    }
    #[inline]
    pub fn add_md5(&mut self, md5: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FileStart::VT_MD5, md5);
    }
    #[inline]
    pub fn add_flag_end(&mut self, flag_end: u8) {
        self.fbb_
            .push_slot::<u8>(FileStart::VT_FLAG_END, flag_end, 0);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FileStart::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileStartBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FileStartBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FileStart<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum BandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Band<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Band<'a> {
    type Inner = Band<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Band<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Band { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BandArgs<'args>,
    ) -> flatbuffers::WIPOffset<Band<'bldr>> {
        let mut builder = BandBuilder::new(_fbb);
        if let Some(x) = args.ht_modes {
            builder.add_ht_modes(x);
        }
        if let Some(x) = args.channels {
            builder.add_channels(x);
        }
        builder.add_band(args.band);
        builder.finish()
    }

    pub const VT_BAND: flatbuffers::VOffsetT = 4;
    pub const VT_CHANNELS: flatbuffers::VOffsetT = 6;
    pub const VT_HT_MODES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn band(&self) -> u8 {
        self._tab.get::<u8>(Band::VT_BAND, Some(0)).unwrap()
    }
    #[inline]
    pub fn channels(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Band::VT_CHANNELS,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn ht_modes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Band::VT_HT_MODES, None)
    }
}

pub struct BandArgs<'a> {
    pub band: u8,
    pub channels: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub ht_modes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for BandArgs<'a> {
    #[inline]
    fn default() -> Self {
        BandArgs {
            band: 0,
            channels: None,
            ht_modes: None,
        }
    }
}
pub struct BandBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BandBuilder<'a, 'b> {
    #[inline]
    pub fn add_band(&mut self, band: u8) {
        self.fbb_.push_slot::<u8>(Band::VT_BAND, band, 0);
    }
    #[inline]
    pub fn add_channels(&mut self, channels: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Band::VT_CHANNELS, channels);
    }
    #[inline]
    pub fn add_ht_modes(
        &mut self,
        ht_modes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Band::VT_HT_MODES, ht_modes);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BandBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BandBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Band<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum IfaceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Iface<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Iface<'a> {
    type Inner = Iface<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Iface<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Iface { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IfaceArgs<'args>,
    ) -> flatbuffers::WIPOffset<Iface<'bldr>> {
        let mut builder = IfaceBuilder::new(_fbb);
        if let Some(x) = args.ports {
            builder.add_ports(x);
        }
        if let Some(x) = args.interfaces {
            builder.add_interfaces(x);
        }
        builder.add_net_mask(args.net_mask);
        builder.add_ip(args.ip);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_vlan_id(args.vlan_id);
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_IP: flatbuffers::VOffsetT = 8;
    pub const VT_NET_MASK: flatbuffers::VOffsetT = 10;
    pub const VT_VLAN_ID: flatbuffers::VOffsetT = 12;
    pub const VT_INTERFACES: flatbuffers::VOffsetT = 14;
    pub const VT_PORTS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub fn type_(&self) -> u8 {
        self._tab.get::<u8>(Iface::VT_TYPE_, Some(0)).unwrap()
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Iface::VT_NAME, None)
    }
    #[inline]
    pub fn ip(&self) -> u32 {
        self._tab.get::<u32>(Iface::VT_IP, Some(0)).unwrap()
    }
    #[inline]
    pub fn net_mask(&self) -> u32 {
        self._tab.get::<u32>(Iface::VT_NET_MASK, Some(0)).unwrap()
    }
    #[inline]
    pub fn vlan_id(&self) -> u16 {
        self._tab.get::<u16>(Iface::VT_VLAN_ID, Some(0)).unwrap()
    }
    #[inline]
    pub fn interfaces(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
        >>(Iface::VT_INTERFACES, None)
    }
    #[inline]
    pub fn ports(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Iface::VT_PORTS, None)
            .map(|v| v.safe_slice())
    }
}

pub struct IfaceArgs<'a> {
    pub type_: u8,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ip: u32,
    pub net_mask: u32,
    pub vlan_id: u16,
    pub interfaces: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub ports: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for IfaceArgs<'a> {
    #[inline]
    fn default() -> Self {
        IfaceArgs {
            type_: 0,
            name: None,
            ip: 0,
            net_mask: 0,
            vlan_id: 0,
            interfaces: None,
            ports: None,
        }
    }
}
pub struct IfaceBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IfaceBuilder<'a, 'b> {
    #[inline]
    pub fn add_type_(&mut self, type_: u8) {
        self.fbb_.push_slot::<u8>(Iface::VT_TYPE_, type_, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Iface::VT_NAME, name);
    }
    #[inline]
    pub fn add_ip(&mut self, ip: u32) {
        self.fbb_.push_slot::<u32>(Iface::VT_IP, ip, 0);
    }
    #[inline]
    pub fn add_net_mask(&mut self, net_mask: u32) {
        self.fbb_.push_slot::<u32>(Iface::VT_NET_MASK, net_mask, 0);
    }
    #[inline]
    pub fn add_vlan_id(&mut self, vlan_id: u16) {
        self.fbb_.push_slot::<u16>(Iface::VT_VLAN_ID, vlan_id, 0);
    }
    #[inline]
    pub fn add_interfaces(
        &mut self,
        interfaces: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Iface::VT_INTERFACES, interfaces);
    }
    #[inline]
    pub fn add_ports(&mut self, ports: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Iface::VT_PORTS, ports);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IfaceBuilder<'a, 'b> {
        let start = _fbb.start_table();
        IfaceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Iface<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoAcaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoAca<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoAca<'a> {
    type Inner = InfoAca<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoAca<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoAca { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoAcaArgs,
    ) -> flatbuffers::WIPOffset<InfoAca<'bldr>> {
        let mut builder = InfoAcaBuilder::new(_fbb);
        builder.add_src(args.src);
        builder.add_enabled(args.enabled);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_ENABLED: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoAca::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn enabled(&self) -> u8 {
        self._tab.get::<u8>(InfoAca::VT_ENABLED, Some(0)).unwrap()
    }
}

pub struct InfoAcaArgs {
    pub src: u32,
    pub enabled: u8,
}
impl<'a> Default for InfoAcaArgs {
    #[inline]
    fn default() -> Self {
        InfoAcaArgs { src: 0, enabled: 0 }
    }
}
pub struct InfoAcaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoAcaBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoAca::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_enabled(&mut self, enabled: u8) {
        self.fbb_.push_slot::<u8>(InfoAca::VT_ENABLED, enabled, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoAcaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoAcaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoAca<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoChannelOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoChannel<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoChannel<'a> {
    type Inner = InfoChannel<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoChannel<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoChannel { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoChannelArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoChannel<'bldr>> {
        let mut builder = InfoChannelBuilder::new(_fbb);
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        builder.add_src(args.src);
        builder.add_channel(args.channel);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_CHANNEL: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoChannel::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoChannel::VT_MAC, None)
    }
    #[inline]
    pub fn channel(&self) -> u8 {
        self._tab
            .get::<u8>(InfoChannel::VT_CHANNEL, Some(0))
            .unwrap()
    }
}

pub struct InfoChannelArgs<'a> {
    pub src: u32,
    pub mac: Option<&'a MacAddress>,
    pub channel: u8,
}
impl<'a> Default for InfoChannelArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoChannelArgs {
            src: 0,
            mac: None,
            channel: 0,
        }
    }
}
pub struct InfoChannelBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoChannelBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoChannel::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoChannel::VT_MAC, mac);
    }
    #[inline]
    pub fn add_channel(&mut self, channel: u8) {
        self.fbb_
            .push_slot::<u8>(InfoChannel::VT_CHANNEL, channel, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoChannelBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoChannelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoChannel<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoIfacesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoIfaces<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoIfaces<'a> {
    type Inner = InfoIfaces<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoIfaces<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoIfaces { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoIfacesArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoIfaces<'bldr>> {
        let mut builder = InfoIfacesBuilder::new(_fbb);
        if let Some(x) = args.list_ifaces {
            builder.add_list_ifaces(x);
        }
        builder.add_src(args.src);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_LIST_IFACES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoIfaces::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn list_ifaces(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Iface<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Iface<'a>>>,
        >>(InfoIfaces::VT_LIST_IFACES, None)
    }
}

pub struct InfoIfacesArgs<'a> {
    pub src: u32,
    pub list_ifaces: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Iface<'a>>>>,
    >,
}
impl<'a> Default for InfoIfacesArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoIfacesArgs {
            src: 0,
            list_ifaces: None,
        }
    }
}
pub struct InfoIfacesBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoIfacesBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoIfaces::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_list_ifaces(
        &mut self,
        list_ifaces: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Iface<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoIfaces::VT_LIST_IFACES, list_ifaces);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoIfacesBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoIfacesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoIfaces<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoLbOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoLb<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoLb<'a> {
    type Inner = InfoLb<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoLb<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoLb { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoLbArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoLb<'bldr>> {
        let mut builder = InfoLbBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        builder.add_src(args.src);
        builder.add_lb_rad_enabled(args.lb_rad_enabled);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_SSID: flatbuffers::VOffsetT = 8;
    pub const VT_LB_RAD_ENABLED: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoLb::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoLb::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoLb::VT_SSID, None)
    }
    #[inline]
    pub fn lb_rad_enabled(&self) -> u8 {
        self._tab
            .get::<u8>(InfoLb::VT_LB_RAD_ENABLED, Some(0))
            .unwrap()
    }
}

pub struct InfoLbArgs<'a> {
    pub src: u32,
    pub phy_mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lb_rad_enabled: u8,
}
impl<'a> Default for InfoLbArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoLbArgs {
            src: 0,
            phy_mac: None,
            ssid: None,
            lb_rad_enabled: 0,
        }
    }
}
pub struct InfoLbBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoLbBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoLb::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoLb::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoLb::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_lb_rad_enabled(&mut self, lb_rad_enabled: u8) {
        self.fbb_
            .push_slot::<u8>(InfoLb::VT_LB_RAD_ENABLED, lb_rad_enabled, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoLbBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoLbBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoLb<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoPreOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoPre<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoPre<'a> {
    type Inner = InfoPre<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoPre<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoPre { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoPreArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoPre<'bldr>> {
        let mut builder = InfoPreBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        builder.add_src(args.src);
        builder.add_pre_rad_enabled(args.pre_rad_enabled);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_SSID: flatbuffers::VOffsetT = 8;
    pub const VT_PRE_RAD_ENABLED: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoPre::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoPre::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoPre::VT_SSID, None)
    }
    #[inline]
    pub fn pre_rad_enabled(&self) -> u8 {
        self._tab
            .get::<u8>(InfoPre::VT_PRE_RAD_ENABLED, Some(0))
            .unwrap()
    }
}

pub struct InfoPreArgs<'a> {
    pub src: u32,
    pub phy_mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pre_rad_enabled: u8,
}
impl<'a> Default for InfoPreArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoPreArgs {
            src: 0,
            phy_mac: None,
            ssid: None,
            pre_rad_enabled: 0,
        }
    }
}
pub struct InfoPreBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoPreBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoPre::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoPre::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoPre::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_pre_rad_enabled(&mut self, pre_rad_enabled: u8) {
        self.fbb_
            .push_slot::<u8>(InfoPre::VT_PRE_RAD_ENABLED, pre_rad_enabled, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoPreBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoPreBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoPre<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoRadioOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoRadio<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoRadio<'a> {
    type Inner = InfoRadio<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoRadio<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoRadio { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoRadioArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoRadio<'bldr>> {
        let mut builder = InfoRadioBuilder::new(_fbb);
        if let Some(x) = args.iface {
            builder.add_iface(x);
        }
        if let Some(x) = args.encryption {
            builder.add_encryption(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        builder.add_src(args.src);
        builder.add_isolate(args.isolate);
        builder.add_hidden(args.hidden);
        builder.add_encryption_type(args.encryption_type);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_MAC: flatbuffers::VOffsetT = 8;
    pub const VT_SSID: flatbuffers::VOffsetT = 10;
    pub const VT_NAME: flatbuffers::VOffsetT = 12;
    pub const VT_ENCRYPTION_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_ENCRYPTION: flatbuffers::VOffsetT = 16;
    pub const VT_IFACE: flatbuffers::VOffsetT = 18;
    pub const VT_HIDDEN: flatbuffers::VOffsetT = 20;
    pub const VT_ISOLATE: flatbuffers::VOffsetT = 22;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoRadio::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoRadio::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoRadio::VT_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoRadio::VT_SSID, None)
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoRadio::VT_NAME, None)
    }
    #[inline]
    pub fn encryption_type(&self) -> Encryption {
        self._tab
            .get::<Encryption>(InfoRadio::VT_ENCRYPTION_TYPE, Some(Encryption::NONE))
            .unwrap()
    }
    #[inline]
    pub fn encryption(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                InfoRadio::VT_ENCRYPTION,
                None,
            )
    }
    #[inline]
    pub fn iface(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoRadio::VT_IFACE, None)
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        self._tab.get::<u8>(InfoRadio::VT_HIDDEN, Some(0)).unwrap()
    }
    #[inline]
    pub fn isolate(&self) -> u8 {
        self._tab.get::<u8>(InfoRadio::VT_ISOLATE, Some(0)).unwrap()
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_none(&self) -> Option<EncNone<'a>> {
        if self.encryption_type() == Encryption::EncNone {
            self.encryption().map(|u| EncNone::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_psk(&self) -> Option<EncPsk<'a>> {
        if self.encryption_type() == Encryption::EncPsk {
            self.encryption().map(|u| EncPsk::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_psk_2(&self) -> Option<EncPsk2<'a>> {
        if self.encryption_type() == Encryption::EncPsk2 {
            self.encryption().map(|u| EncPsk2::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_psk_mixed(&self) -> Option<EncPskMixed<'a>> {
        if self.encryption_type() == Encryption::EncPskMixed {
            self.encryption().map(|u| EncPskMixed::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wep(&self) -> Option<EncWep<'a>> {
        if self.encryption_type() == Encryption::EncWep {
            self.encryption().map(|u| EncWep::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wpa(&self) -> Option<EncWpa<'a>> {
        if self.encryption_type() == Encryption::EncWpa {
            self.encryption().map(|u| EncWpa::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wpa_2(&self) -> Option<EncWpa2<'a>> {
        if self.encryption_type() == Encryption::EncWpa2 {
            self.encryption().map(|u| EncWpa2::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wpa_mixed(&self) -> Option<EncWpaMixed<'a>> {
        if self.encryption_type() == Encryption::EncWpaMixed {
            self.encryption().map(|u| EncWpaMixed::init_from_table(u))
        } else {
            None
        }
    }
}

pub struct InfoRadioArgs<'a> {
    pub src: u32,
    pub phy_mac: Option<&'a MacAddress>,
    pub mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encryption_type: Encryption,
    pub encryption: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub iface: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hidden: u8,
    pub isolate: u8,
}
impl<'a> Default for InfoRadioArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoRadioArgs {
            src: 0,
            phy_mac: None,
            mac: None,
            ssid: None,
            name: None,
            encryption_type: Encryption::NONE,
            encryption: None,
            iface: None,
            hidden: 0,
            isolate: 0,
        }
    }
}
pub struct InfoRadioBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoRadioBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoRadio::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoRadio::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoRadio::VT_MAC, mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoRadio::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoRadio::VT_NAME, name);
    }
    #[inline]
    pub fn add_encryption_type(&mut self, encryption_type: Encryption) {
        self.fbb_.push_slot::<Encryption>(
            InfoRadio::VT_ENCRYPTION_TYPE,
            encryption_type,
            Encryption::NONE,
        );
    }
    #[inline]
    pub fn add_encryption(
        &mut self,
        encryption: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoRadio::VT_ENCRYPTION, encryption);
    }
    #[inline]
    pub fn add_iface(&mut self, iface: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoRadio::VT_IFACE, iface);
    }
    #[inline]
    pub fn add_hidden(&mut self, hidden: u8) {
        self.fbb_.push_slot::<u8>(InfoRadio::VT_HIDDEN, hidden, 0);
    }
    #[inline]
    pub fn add_isolate(&mut self, isolate: u8) {
        self.fbb_.push_slot::<u8>(InfoRadio::VT_ISOLATE, isolate, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoRadioBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoRadioBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoRadio<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoSrOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoSr<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoSr<'a> {
    type Inner = InfoSr<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoSr<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoSr { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoSrArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoSr<'bldr>> {
        let mut builder = InfoSrBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        builder.add_src(args.src);
        builder.add_sr_rad_enabled(args.sr_rad_enabled);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_SSID: flatbuffers::VOffsetT = 8;
    pub const VT_SR_RAD_ENABLED: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoSr::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoSr::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoSr::VT_SSID, None)
    }
    #[inline]
    pub fn sr_rad_enabled(&self) -> u8 {
        self._tab
            .get::<u8>(InfoSr::VT_SR_RAD_ENABLED, Some(0))
            .unwrap()
    }
}

pub struct InfoSrArgs<'a> {
    pub src: u32,
    pub phy_mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sr_rad_enabled: u8,
}
impl<'a> Default for InfoSrArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoSrArgs {
            src: 0,
            phy_mac: None,
            ssid: None,
            sr_rad_enabled: 0,
        }
    }
}
pub struct InfoSrBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoSrBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoSr::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoSr::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoSr::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_sr_rad_enabled(&mut self, sr_rad_enabled: u8) {
        self.fbb_
            .push_slot::<u8>(InfoSr::VT_SR_RAD_ENABLED, sr_rad_enabled, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoSrBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoSrBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoSr<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoStaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoSta<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoSta<'a> {
    type Inner = InfoSta<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoSta<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoSta { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoStaArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoSta<'bldr>> {
        let mut builder = InfoStaBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        builder.add_src(args.src);
        builder.add_dual_band(args.dual_band);
        builder.add_r(args.r);
        builder.add_k(args.k);
        builder.add_wnm(args.wnm);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 8;
    pub const VT_SSID: flatbuffers::VOffsetT = 10;
    pub const VT_WNM: flatbuffers::VOffsetT = 12;
    pub const VT_K: flatbuffers::VOffsetT = 14;
    pub const VT_R: flatbuffers::VOffsetT = 16;
    pub const VT_DUAL_BAND: flatbuffers::VOffsetT = 18;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoSta::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoSta::VT_MAC, None)
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoSta::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoSta::VT_SSID, None)
    }
    #[inline]
    pub fn wnm(&self) -> u8 {
        self._tab.get::<u8>(InfoSta::VT_WNM, Some(1)).unwrap()
    }
    #[inline]
    pub fn k(&self) -> u8 {
        self._tab.get::<u8>(InfoSta::VT_K, Some(1)).unwrap()
    }
    #[inline]
    pub fn r(&self) -> u8 {
        self._tab.get::<u8>(InfoSta::VT_R, Some(1)).unwrap()
    }
    #[inline]
    pub fn dual_band(&self) -> u8 {
        self._tab.get::<u8>(InfoSta::VT_DUAL_BAND, Some(1)).unwrap()
    }
}

pub struct InfoStaArgs<'a> {
    pub src: u32,
    pub mac: Option<&'a MacAddress>,
    pub phy_mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wnm: u8,
    pub k: u8,
    pub r: u8,
    pub dual_band: u8,
}
impl<'a> Default for InfoStaArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoStaArgs {
            src: 0,
            mac: None,
            phy_mac: None,
            ssid: None,
            wnm: 1,
            k: 1,
            r: 1,
            dual_band: 1,
        }
    }
}
pub struct InfoStaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoStaBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoSta::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoSta::VT_MAC, mac);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoSta::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoSta::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_wnm(&mut self, wnm: u8) {
        self.fbb_.push_slot::<u8>(InfoSta::VT_WNM, wnm, 1);
    }
    #[inline]
    pub fn add_k(&mut self, k: u8) {
        self.fbb_.push_slot::<u8>(InfoSta::VT_K, k, 1);
    }
    #[inline]
    pub fn add_r(&mut self, r: u8) {
        self.fbb_.push_slot::<u8>(InfoSta::VT_R, r, 1);
    }
    #[inline]
    pub fn add_dual_band(&mut self, dual_band: u8) {
        self.fbb_
            .push_slot::<u8>(InfoSta::VT_DUAL_BAND, dual_band, 1);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoStaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoStaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoSta<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoTcOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoTc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoTc<'a> {
    type Inner = InfoTc<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoTc<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoTc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoTcArgs<'args>,
    ) -> flatbuffers::WIPOffset<InfoTc<'bldr>> {
        let mut builder = InfoTcBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_mac {
            builder.add_phy_mac(x);
        }
        builder.add_src(args.src);
        builder.add_thr_min(args.thr_min);
        builder.add_thr_max(args.thr_max);
        builder.add_enabled(args.enabled);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_PHY_MAC: flatbuffers::VOffsetT = 6;
    pub const VT_SSID: flatbuffers::VOffsetT = 8;
    pub const VT_ENABLED: flatbuffers::VOffsetT = 10;
    pub const VT_THR_MAX: flatbuffers::VOffsetT = 12;
    pub const VT_THR_MIN: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoTc::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn phy_mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(InfoTc::VT_PHY_MAC, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InfoTc::VT_SSID, None)
    }
    #[inline]
    pub fn enabled(&self) -> u8 {
        self._tab.get::<u8>(InfoTc::VT_ENABLED, Some(0)).unwrap()
    }
    #[inline]
    pub fn thr_max(&self) -> u16 {
        self._tab.get::<u16>(InfoTc::VT_THR_MAX, Some(0)).unwrap()
    }
    #[inline]
    pub fn thr_min(&self) -> u16 {
        self._tab.get::<u16>(InfoTc::VT_THR_MIN, Some(0)).unwrap()
    }
}

pub struct InfoTcArgs<'a> {
    pub src: u32,
    pub phy_mac: Option<&'a MacAddress>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enabled: u8,
    pub thr_max: u16,
    pub thr_min: u16,
}
impl<'a> Default for InfoTcArgs<'a> {
    #[inline]
    fn default() -> Self {
        InfoTcArgs {
            src: 0,
            phy_mac: None,
            ssid: None,
            enabled: 0,
            thr_max: 0,
            thr_min: 0,
        }
    }
}
pub struct InfoTcBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoTcBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoTc::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_phy_mac(&mut self, phy_mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(InfoTc::VT_PHY_MAC, phy_mac);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InfoTc::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_enabled(&mut self, enabled: u8) {
        self.fbb_.push_slot::<u8>(InfoTc::VT_ENABLED, enabled, 0);
    }
    #[inline]
    pub fn add_thr_max(&mut self, thr_max: u16) {
        self.fbb_.push_slot::<u16>(InfoTc::VT_THR_MAX, thr_max, 0);
    }
    #[inline]
    pub fn add_thr_min(&mut self, thr_min: u16) {
        self.fbb_.push_slot::<u16>(InfoTc::VT_THR_MIN, thr_min, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoTcBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoTcBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoTc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum InfoZoneOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InfoZone<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InfoZone<'a> {
    type Inner = InfoZone<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InfoZone<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InfoZone { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InfoZoneArgs,
    ) -> flatbuffers::WIPOffset<InfoZone<'bldr>> {
        let mut builder = InfoZoneBuilder::new(_fbb);
        builder.add_ip(args.ip);
        builder.add_src(args.src);
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_IP: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(InfoZone::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn ip(&self) -> u32 {
        self._tab.get::<u32>(InfoZone::VT_IP, Some(0)).unwrap()
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        self._tab.get::<u8>(InfoZone::VT_TYPE_, Some(2)).unwrap()
    }
}

pub struct InfoZoneArgs {
    pub src: u32,
    pub ip: u32,
    pub type_: u8,
}
impl<'a> Default for InfoZoneArgs {
    #[inline]
    fn default() -> Self {
        InfoZoneArgs {
            src: 0,
            ip: 0,
            type_: 2,
        }
    }
}
pub struct InfoZoneBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfoZoneBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(InfoZone::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_ip(&mut self, ip: u32) {
        self.fbb_.push_slot::<u32>(InfoZone::VT_IP, ip, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: u8) {
        self.fbb_.push_slot::<u8>(InfoZone::VT_TYPE_, type_, 2);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoZoneBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InfoZoneBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InfoZone<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum ListStatStaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ListStatSta<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ListStatSta<'a> {
    type Inner = ListStatSta<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ListStatSta<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ListStatSta { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ListStatStaArgs<'args>,
    ) -> flatbuffers::WIPOffset<ListStatSta<'bldr>> {
        let mut builder = ListStatStaBuilder::new(_fbb);
        if let Some(x) = args.list {
            builder.add_list(x);
        }
        builder.add_src(args.src);
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_LIST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(ListStatSta::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn list(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StatSta<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<StatSta<'a>>>,
        >>(ListStatSta::VT_LIST, None)
    }
}

pub struct ListStatStaArgs<'a> {
    pub src: u32,
    pub list: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StatSta<'a>>>>,
    >,
}
impl<'a> Default for ListStatStaArgs<'a> {
    #[inline]
    fn default() -> Self {
        ListStatStaArgs { src: 0, list: None }
    }
}
pub struct ListStatStaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ListStatStaBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(ListStatSta::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_list(
        &mut self,
        list: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<StatSta<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ListStatSta::VT_LIST, list);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ListStatStaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ListStatStaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ListStatSta<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum ModuleOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Module<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Module<'a> {
    type Inner = Module<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Module<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Module { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ModuleArgs<'args>,
    ) -> flatbuffers::WIPOffset<Module<'bldr>> {
        let mut builder = ModuleBuilder::new(_fbb);
        if let Some(x) = args.version {
            builder.add_version(x);
        }
        builder.add_hash(args.hash);
        builder.add_licensed(args.licensed);
        builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_LICENSED: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn hash(&self) -> u16 {
        self._tab.get::<u16>(Module::VT_HASH, Some(0)).unwrap()
    }
    #[inline]
    pub fn version(&self) -> Option<&'a Version> {
        self._tab.get::<Version>(Module::VT_VERSION, None)
    }
    #[inline]
    pub fn licensed(&self) -> u8 {
        self._tab.get::<u8>(Module::VT_LICENSED, Some(0)).unwrap()
    }
}

pub struct ModuleArgs<'a> {
    pub hash: u16,
    pub version: Option<&'a Version>,
    pub licensed: u8,
}
impl<'a> Default for ModuleArgs<'a> {
    #[inline]
    fn default() -> Self {
        ModuleArgs {
            hash: 0,
            version: None,
            licensed: 0,
        }
    }
}
pub struct ModuleBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModuleBuilder<'a, 'b> {
    #[inline]
    pub fn add_hash(&mut self, hash: u16) {
        self.fbb_.push_slot::<u16>(Module::VT_HASH, hash, 0);
    }
    #[inline]
    pub fn add_version(&mut self, version: &'b Version) {
        self.fbb_
            .push_slot_always::<&Version>(Module::VT_VERSION, version);
    }
    #[inline]
    pub fn add_licensed(&mut self, licensed: u8) {
        self.fbb_.push_slot::<u8>(Module::VT_LICENSED, licensed, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModuleBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ModuleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Module<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum MgrConnOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MgrConn<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MgrConn<'a> {
    type Inner = MgrConn<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MgrConn<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MgrConn { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args MgrConnArgs,
    ) -> flatbuffers::WIPOffset<MgrConn<'bldr>> {
        let mut builder = MgrConnBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct MgrConnArgs {}
impl<'a> Default for MgrConnArgs {
    #[inline]
    fn default() -> Self {
        MgrConnArgs {}
    }
}
pub struct MgrConnBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MgrConnBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MgrConnBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MgrConnBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MgrConn<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum MgrDiscOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MgrDisc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MgrDisc<'a> {
    type Inner = MgrDisc<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MgrDisc<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MgrDisc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args MgrDiscArgs,
    ) -> flatbuffers::WIPOffset<MgrDisc<'bldr>> {
        let mut builder = MgrDiscBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct MgrDiscArgs {}
impl<'a> Default for MgrDiscArgs {
    #[inline]
    fn default() -> Self {
        MgrDiscArgs {}
    }
}
pub struct MgrDiscBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MgrDiscBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MgrDiscBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MgrDiscBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MgrDisc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum ResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Response<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Response<'a> {
    type Inner = Response<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Response<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Response { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ResponseArgs,
    ) -> flatbuffers::WIPOffset<Response<'bldr>> {
        let mut builder = ResponseBuilder::new(_fbb);
        builder.add_id(args.id);
        builder.add_err(args.err);
        builder.add_src(args.src);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SRC: flatbuffers::VOffsetT = 6;
    pub const VT_ERR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn id(&self) -> u64 {
        self._tab.get::<u64>(Response::VT_ID, Some(0)).unwrap()
    }
    #[inline]
    pub fn src(&self) -> u32 {
        self._tab.get::<u32>(Response::VT_SRC, Some(0)).unwrap()
    }
    #[inline]
    pub fn err(&self) -> i32 {
        self._tab.get::<i32>(Response::VT_ERR, Some(0)).unwrap()
    }
}

pub struct ResponseArgs {
    pub id: u64,
    pub src: u32,
    pub err: i32,
}
impl<'a> Default for ResponseArgs {
    #[inline]
    fn default() -> Self {
        ResponseArgs {
            id: 0,
            src: 0,
            err: 0,
        }
    }
}
pub struct ResponseBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResponseBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: u64) {
        self.fbb_.push_slot::<u64>(Response::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_src(&mut self, src: u32) {
        self.fbb_.push_slot::<u32>(Response::VT_SRC, src, 0);
    }
    #[inline]
    pub fn add_err(&mut self, err: i32) {
        self.fbb_.push_slot::<i32>(Response::VT_ERR, err, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResponseBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Response<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StatStaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StatSta<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StatSta<'a> {
    type Inner = StatSta<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StatSta<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StatSta { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StatStaArgs<'args>,
    ) -> flatbuffers::WIPOffset<StatSta<'bldr>> {
        let mut builder = StatStaBuilder::new(_fbb);
        builder.add_aptimestamp(args.aptimestamp);
        if let Some(x) = args.loc {
            builder.add_loc(x);
        }
        builder.add_rx_failed(args.rx_failed);
        builder.add_rx_retries(args.rx_retries);
        builder.add_tx_bytes(args.tx_bytes);
        builder.add_rx_bytes(args.rx_bytes);
        builder.add_tx_rate(args.tx_rate);
        builder.add_rx_rate(args.rx_rate);
        builder.add_tx_packets(args.tx_packets);
        builder.add_rx_packets(args.rx_packets);
        if let Some(x) = args.mac {
            builder.add_mac(x);
        }
        builder.add_tx_vht_nss(args.tx_vht_nss);
        builder.add_tx_mhz(args.tx_mhz);
        builder.add_tx_flags(args.tx_flags);
        builder.add_tx_mcs(args.tx_mcs);
        builder.add_rx_vht_nss(args.rx_vht_nss);
        builder.add_rx_mhz(args.rx_mhz);
        builder.add_rx_flags(args.rx_flags);
        builder.add_rx_mcs(args.rx_mcs);
        builder.add_noise(args.noise);
        builder.add_signal(args.signal);
        builder.add_snr(args.snr);
        builder.finish()
    }

    pub const VT_MAC: flatbuffers::VOffsetT = 4;
    pub const VT_SNR: flatbuffers::VOffsetT = 6;
    pub const VT_SIGNAL: flatbuffers::VOffsetT = 8;
    pub const VT_NOISE: flatbuffers::VOffsetT = 10;
    pub const VT_RX_PACKETS: flatbuffers::VOffsetT = 12;
    pub const VT_TX_PACKETS: flatbuffers::VOffsetT = 14;
    pub const VT_RX_RATE: flatbuffers::VOffsetT = 16;
    pub const VT_RX_MCS: flatbuffers::VOffsetT = 18;
    pub const VT_RX_FLAGS: flatbuffers::VOffsetT = 20;
    pub const VT_RX_MHZ: flatbuffers::VOffsetT = 22;
    pub const VT_RX_VHT_NSS: flatbuffers::VOffsetT = 24;
    pub const VT_TX_RATE: flatbuffers::VOffsetT = 26;
    pub const VT_TX_MCS: flatbuffers::VOffsetT = 28;
    pub const VT_TX_FLAGS: flatbuffers::VOffsetT = 30;
    pub const VT_TX_MHZ: flatbuffers::VOffsetT = 32;
    pub const VT_TX_VHT_NSS: flatbuffers::VOffsetT = 34;
    pub const VT_RX_BYTES: flatbuffers::VOffsetT = 36;
    pub const VT_TX_BYTES: flatbuffers::VOffsetT = 38;
    pub const VT_RX_RETRIES: flatbuffers::VOffsetT = 40;
    pub const VT_RX_FAILED: flatbuffers::VOffsetT = 42;
    pub const VT_LOC: flatbuffers::VOffsetT = 44;
    pub const VT_APTIMESTAMP: flatbuffers::VOffsetT = 46;

    #[inline]
    pub fn mac(&self) -> Option<&'a MacAddress> {
        self._tab.get::<MacAddress>(StatSta::VT_MAC, None)
    }
    #[inline]
    pub fn snr(&self) -> u8 {
        self._tab.get::<u8>(StatSta::VT_SNR, Some(0)).unwrap()
    }
    #[inline]
    pub fn signal(&self) -> i8 {
        self._tab.get::<i8>(StatSta::VT_SIGNAL, Some(0)).unwrap()
    }
    #[inline]
    pub fn noise(&self) -> i8 {
        self._tab.get::<i8>(StatSta::VT_NOISE, Some(0)).unwrap()
    }
    #[inline]
    pub fn rx_packets(&self) -> u32 {
        self._tab
            .get::<u32>(StatSta::VT_RX_PACKETS, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn tx_packets(&self) -> u32 {
        self._tab
            .get::<u32>(StatSta::VT_TX_PACKETS, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn rx_rate(&self) -> u32 {
        self._tab.get::<u32>(StatSta::VT_RX_RATE, Some(0)).unwrap()
    }
    #[inline]
    pub fn rx_mcs(&self) -> i8 {
        self._tab.get::<i8>(StatSta::VT_RX_MCS, Some(0)).unwrap()
    }
    #[inline]
    pub fn rx_flags(&self) -> u8 {
        self._tab.get::<u8>(StatSta::VT_RX_FLAGS, Some(0)).unwrap()
    }
    #[inline]
    pub fn rx_mhz(&self) -> u8 {
        self._tab.get::<u8>(StatSta::VT_RX_MHZ, Some(20)).unwrap()
    }
    #[inline]
    pub fn rx_vht_nss(&self) -> u8 {
        self._tab
            .get::<u8>(StatSta::VT_RX_VHT_NSS, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn tx_rate(&self) -> u32 {
        self._tab.get::<u32>(StatSta::VT_TX_RATE, Some(0)).unwrap()
    }
    #[inline]
    pub fn tx_mcs(&self) -> i8 {
        self._tab.get::<i8>(StatSta::VT_TX_MCS, Some(0)).unwrap()
    }
    #[inline]
    pub fn tx_flags(&self) -> u8 {
        self._tab.get::<u8>(StatSta::VT_TX_FLAGS, Some(0)).unwrap()
    }
    #[inline]
    pub fn tx_mhz(&self) -> u8 {
        self._tab.get::<u8>(StatSta::VT_TX_MHZ, Some(20)).unwrap()
    }
    #[inline]
    pub fn tx_vht_nss(&self) -> u8 {
        self._tab
            .get::<u8>(StatSta::VT_TX_VHT_NSS, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn rx_bytes(&self) -> u32 {
        self._tab.get::<u32>(StatSta::VT_RX_BYTES, Some(0)).unwrap()
    }
    #[inline]
    pub fn tx_bytes(&self) -> u32 {
        self._tab.get::<u32>(StatSta::VT_TX_BYTES, Some(0)).unwrap()
    }
    #[inline]
    pub fn rx_retries(&self) -> u32 {
        self._tab
            .get::<u32>(StatSta::VT_RX_RETRIES, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn rx_failed(&self) -> u32 {
        self._tab
            .get::<u32>(StatSta::VT_RX_FAILED, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn loc(&self) -> Option<&'a Loc3Float> {
        self._tab.get::<Loc3Float>(StatSta::VT_LOC, None)
    }
    #[inline]
    pub fn aptimestamp(&self) -> u64 {
        self._tab
            .get::<u64>(StatSta::VT_APTIMESTAMP, Some(0))
            .unwrap()
    }
}

pub struct StatStaArgs<'a> {
    pub mac: Option<&'a MacAddress>,
    pub snr: u8,
    pub signal: i8,
    pub noise: i8,
    pub rx_packets: u32,
    pub tx_packets: u32,
    pub rx_rate: u32,
    pub rx_mcs: i8,
    pub rx_flags: u8,
    pub rx_mhz: u8,
    pub rx_vht_nss: u8,
    pub tx_rate: u32,
    pub tx_mcs: i8,
    pub tx_flags: u8,
    pub tx_mhz: u8,
    pub tx_vht_nss: u8,
    pub rx_bytes: u32,
    pub tx_bytes: u32,
    pub rx_retries: u32,
    pub rx_failed: u32,
    pub loc: Option<&'a Loc3Float>,
    pub aptimestamp: u64,
}
impl<'a> Default for StatStaArgs<'a> {
    #[inline]
    fn default() -> Self {
        StatStaArgs {
            mac: None,
            snr: 0,
            signal: 0,
            noise: 0,
            rx_packets: 0,
            tx_packets: 0,
            rx_rate: 0,
            rx_mcs: 0,
            rx_flags: 0,
            rx_mhz: 20,
            rx_vht_nss: 0,
            tx_rate: 0,
            tx_mcs: 0,
            tx_flags: 0,
            tx_mhz: 20,
            tx_vht_nss: 0,
            rx_bytes: 0,
            tx_bytes: 0,
            rx_retries: 0,
            rx_failed: 0,
            loc: None,
            aptimestamp: 0,
        }
    }
}
pub struct StatStaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StatStaBuilder<'a, 'b> {
    #[inline]
    pub fn add_mac(&mut self, mac: &'b MacAddress) {
        self.fbb_
            .push_slot_always::<&MacAddress>(StatSta::VT_MAC, mac);
    }
    #[inline]
    pub fn add_snr(&mut self, snr: u8) {
        self.fbb_.push_slot::<u8>(StatSta::VT_SNR, snr, 0);
    }
    #[inline]
    pub fn add_signal(&mut self, signal: i8) {
        self.fbb_.push_slot::<i8>(StatSta::VT_SIGNAL, signal, 0);
    }
    #[inline]
    pub fn add_noise(&mut self, noise: i8) {
        self.fbb_.push_slot::<i8>(StatSta::VT_NOISE, noise, 0);
    }
    #[inline]
    pub fn add_rx_packets(&mut self, rx_packets: u32) {
        self.fbb_
            .push_slot::<u32>(StatSta::VT_RX_PACKETS, rx_packets, 0);
    }
    #[inline]
    pub fn add_tx_packets(&mut self, tx_packets: u32) {
        self.fbb_
            .push_slot::<u32>(StatSta::VT_TX_PACKETS, tx_packets, 0);
    }
    #[inline]
    pub fn add_rx_rate(&mut self, rx_rate: u32) {
        self.fbb_.push_slot::<u32>(StatSta::VT_RX_RATE, rx_rate, 0);
    }
    #[inline]
    pub fn add_rx_mcs(&mut self, rx_mcs: i8) {
        self.fbb_.push_slot::<i8>(StatSta::VT_RX_MCS, rx_mcs, 0);
    }
    #[inline]
    pub fn add_rx_flags(&mut self, rx_flags: u8) {
        self.fbb_.push_slot::<u8>(StatSta::VT_RX_FLAGS, rx_flags, 0);
    }
    #[inline]
    pub fn add_rx_mhz(&mut self, rx_mhz: u8) {
        self.fbb_.push_slot::<u8>(StatSta::VT_RX_MHZ, rx_mhz, 20);
    }
    #[inline]
    pub fn add_rx_vht_nss(&mut self, rx_vht_nss: u8) {
        self.fbb_
            .push_slot::<u8>(StatSta::VT_RX_VHT_NSS, rx_vht_nss, 0);
    }
    #[inline]
    pub fn add_tx_rate(&mut self, tx_rate: u32) {
        self.fbb_.push_slot::<u32>(StatSta::VT_TX_RATE, tx_rate, 0);
    }
    #[inline]
    pub fn add_tx_mcs(&mut self, tx_mcs: i8) {
        self.fbb_.push_slot::<i8>(StatSta::VT_TX_MCS, tx_mcs, 0);
    }
    #[inline]
    pub fn add_tx_flags(&mut self, tx_flags: u8) {
        self.fbb_.push_slot::<u8>(StatSta::VT_TX_FLAGS, tx_flags, 0);
    }
    #[inline]
    pub fn add_tx_mhz(&mut self, tx_mhz: u8) {
        self.fbb_.push_slot::<u8>(StatSta::VT_TX_MHZ, tx_mhz, 20);
    }
    #[inline]
    pub fn add_tx_vht_nss(&mut self, tx_vht_nss: u8) {
        self.fbb_
            .push_slot::<u8>(StatSta::VT_TX_VHT_NSS, tx_vht_nss, 0);
    }
    #[inline]
    pub fn add_rx_bytes(&mut self, rx_bytes: u32) {
        self.fbb_
            .push_slot::<u32>(StatSta::VT_RX_BYTES, rx_bytes, 0);
    }
    #[inline]
    pub fn add_tx_bytes(&mut self, tx_bytes: u32) {
        self.fbb_
            .push_slot::<u32>(StatSta::VT_TX_BYTES, tx_bytes, 0);
    }
    #[inline]
    pub fn add_rx_retries(&mut self, rx_retries: u32) {
        self.fbb_
            .push_slot::<u32>(StatSta::VT_RX_RETRIES, rx_retries, 0);
    }
    #[inline]
    pub fn add_rx_failed(&mut self, rx_failed: u32) {
        self.fbb_
            .push_slot::<u32>(StatSta::VT_RX_FAILED, rx_failed, 0);
    }
    #[inline]
    pub fn add_loc(&mut self, loc: &'b Loc3Float) {
        self.fbb_
            .push_slot_always::<&Loc3Float>(StatSta::VT_LOC, loc);
    }
    #[inline]
    pub fn add_aptimestamp(&mut self, aptimestamp: u64) {
        self.fbb_
            .push_slot::<u64>(StatSta::VT_APTIMESTAMP, aptimestamp, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StatStaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StatStaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StatSta<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

#[inline]
pub fn get_root_as_container<'a>(buf: &'a [u8]) -> Container<'a> {
    flatbuffers::get_root::<Container<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_container<'a>(buf: &'a [u8]) -> Container<'a> {
    flatbuffers::get_size_prefixed_root::<Container<'a>>(buf)
}

#[inline]
pub fn finish_container_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Container<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_container_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Container<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
