// automatically generated by the FlatBuffers compiler, do not modify

extern crate flatbuffers;
use crate::cht::utils::*;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum CmdType {
    NONE = 0,
    AddToChtZone = 1,
    AcaDisable = 2,
    AcaEnable = 3,
    ApInfo = 4,
    Apply = 5,
    Backup = 6,
    CreateVlan = 7,
    CreateVradio = 8,
    DisableRadio = 9,
    EnableRadio = 10,
    Flash = 11,
    LocRemoveMyPos = 12,
    LocSetMyPos = 13,
    Reboot = 14,
    RemoveFromChtZone = 15,
    RemoveVlan = 16,
    RemoveVradio = 17,
    Restore = 18,
    SetChannel = 19,
    SetOpMode = 20,
    SetPower = 21,
    SetReportCrashes = 22,
    TcDisable = 23,
    TcEnable = 24,
}

const ENUM_MIN_CMD_TYPE: u8 = 0;
const ENUM_MAX_CMD_TYPE: u8 = 24;

impl<'a> flatbuffers::Follow<'a> for CmdType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for CmdType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const CmdType;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const CmdType;
        unsafe { *p }
    }
}

impl flatbuffers::Push for CmdType {
    type Output = CmdType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<CmdType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_CMD_TYPE: [CmdType; 25] = [
    CmdType::NONE,
    CmdType::AddToChtZone,
    CmdType::AcaDisable,
    CmdType::AcaEnable,
    CmdType::ApInfo,
    CmdType::Apply,
    CmdType::Backup,
    CmdType::CreateVlan,
    CmdType::CreateVradio,
    CmdType::DisableRadio,
    CmdType::EnableRadio,
    CmdType::Flash,
    CmdType::LocRemoveMyPos,
    CmdType::LocSetMyPos,
    CmdType::Reboot,
    CmdType::RemoveFromChtZone,
    CmdType::RemoveVlan,
    CmdType::RemoveVradio,
    CmdType::Restore,
    CmdType::SetChannel,
    CmdType::SetOpMode,
    CmdType::SetPower,
    CmdType::SetReportCrashes,
    CmdType::TcDisable,
    CmdType::TcEnable,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_CMD_TYPE: [&'static str; 25] = [
    "NONE",
    "AddToChtZone",
    "AcaDisable",
    "AcaEnable",
    "ApInfo",
    "Apply",
    "Backup",
    "CreateVlan",
    "CreateVradio",
    "DisableRadio",
    "EnableRadio",
    "Flash",
    "LocRemoveMyPos",
    "LocSetMyPos",
    "Reboot",
    "RemoveFromChtZone",
    "RemoveVlan",
    "RemoveVradio",
    "Restore",
    "SetChannel",
    "SetOpMode",
    "SetPower",
    "SetReportCrashes",
    "TcDisable",
    "TcEnable",
];

pub fn enum_name_cmd_type(e: CmdType) -> &'static str {
    let index = e as u8;
    ENUM_NAMES_CMD_TYPE[index as usize]
}

pub struct CmdTypeUnionTableOffset {}
pub enum ApInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ApInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ApInfo<'a> {
    type Inner = ApInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ApInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ApInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ApInfoArgs,
    ) -> flatbuffers::WIPOffset<ApInfo<'bldr>> {
        let mut builder = ApInfoBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct ApInfoArgs {}
impl<'a> Default for ApInfoArgs {
    #[inline]
    fn default() -> Self {
        ApInfoArgs {}
    }
}
pub struct ApInfoBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ApInfoBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ApInfoBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ApInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ApInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum RebootOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Reboot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Reboot<'a> {
    type Inner = Reboot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Reboot<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Reboot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args RebootArgs,
    ) -> flatbuffers::WIPOffset<Reboot<'bldr>> {
        let mut builder = RebootBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct RebootArgs {}
impl<'a> Default for RebootArgs {
    #[inline]
    fn default() -> Self {
        RebootArgs {}
    }
}
pub struct RebootBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RebootBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RebootBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RebootBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Reboot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum ApplyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Apply<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Apply<'a> {
    type Inner = Apply<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Apply<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Apply { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ApplyArgs,
    ) -> flatbuffers::WIPOffset<Apply<'bldr>> {
        let mut builder = ApplyBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct ApplyArgs {}
impl<'a> Default for ApplyArgs {
    #[inline]
    fn default() -> Self {
        ApplyArgs {}
    }
}
pub struct ApplyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ApplyBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ApplyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ApplyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Apply<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum CreateVlanOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CreateVlan<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateVlan<'a> {
    type Inner = CreateVlan<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CreateVlan<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CreateVlan { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CreateVlanArgs<'args>,
    ) -> flatbuffers::WIPOffset<CreateVlan<'bldr>> {
        let mut builder = CreateVlanBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.ports {
            builder.add_ports(x);
        }
        builder.add_vlan_id(args.vlan_id);
        builder.finish()
    }

    pub const VT_VLAN_ID: flatbuffers::VOffsetT = 4;
    pub const VT_PORTS: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn vlan_id(&self) -> u16 {
        self._tab
            .get::<u16>(CreateVlan::VT_VLAN_ID, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn ports(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CreateVlan::VT_PORTS, None)
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CreateVlan::VT_NAME, None)
    }
}

pub struct CreateVlanArgs<'a> {
    pub vlan_id: u16,
    pub ports: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreateVlanArgs<'a> {
    #[inline]
    fn default() -> Self {
        CreateVlanArgs {
            vlan_id: 0,
            ports: None,
            name: None,
        }
    }
}
pub struct CreateVlanBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateVlanBuilder<'a, 'b> {
    #[inline]
    pub fn add_vlan_id(&mut self, vlan_id: u16) {
        self.fbb_
            .push_slot::<u16>(CreateVlan::VT_VLAN_ID, vlan_id, 0);
    }
    #[inline]
    pub fn add_ports(&mut self, ports: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CreateVlan::VT_PORTS, ports);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CreateVlan::VT_NAME, name);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CreateVlanBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CreateVlanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CreateVlan<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum RemoveVlanOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RemoveVlan<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RemoveVlan<'a> {
    type Inner = RemoveVlan<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RemoveVlan<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RemoveVlan { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RemoveVlanArgs,
    ) -> flatbuffers::WIPOffset<RemoveVlan<'bldr>> {
        let mut builder = RemoveVlanBuilder::new(_fbb);
        builder.add_vlan_id(args.vlan_id);
        builder.finish()
    }

    pub const VT_VLAN_ID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn vlan_id(&self) -> u16 {
        self._tab
            .get::<u16>(RemoveVlan::VT_VLAN_ID, Some(0))
            .unwrap()
    }
}

pub struct RemoveVlanArgs {
    pub vlan_id: u16,
}
impl<'a> Default for RemoveVlanArgs {
    #[inline]
    fn default() -> Self {
        RemoveVlanArgs { vlan_id: 0 }
    }
}
pub struct RemoveVlanBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RemoveVlanBuilder<'a, 'b> {
    #[inline]
    pub fn add_vlan_id(&mut self, vlan_id: u16) {
        self.fbb_
            .push_slot::<u16>(RemoveVlan::VT_VLAN_ID, vlan_id, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RemoveVlanBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RemoveVlanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RemoveVlan<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum AddToChtZoneOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AddToChtZone<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddToChtZone<'a> {
    type Inner = AddToChtZone<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AddToChtZone<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AddToChtZone { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AddToChtZoneArgs,
    ) -> flatbuffers::WIPOffset<AddToChtZone<'bldr>> {
        let mut builder = AddToChtZoneBuilder::new(_fbb);
        builder.add_zone(args.zone);
        builder.finish()
    }

    pub const VT_ZONE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn zone(&self) -> u32 {
        self._tab
            .get::<u32>(AddToChtZone::VT_ZONE, Some(0))
            .unwrap()
    }
}

pub struct AddToChtZoneArgs {
    pub zone: u32,
}
impl<'a> Default for AddToChtZoneArgs {
    #[inline]
    fn default() -> Self {
        AddToChtZoneArgs { zone: 0 }
    }
}
pub struct AddToChtZoneBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddToChtZoneBuilder<'a, 'b> {
    #[inline]
    pub fn add_zone(&mut self, zone: u32) {
        self.fbb_.push_slot::<u32>(AddToChtZone::VT_ZONE, zone, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddToChtZoneBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AddToChtZoneBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AddToChtZone<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum RemoveFromChtZoneOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RemoveFromChtZone<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RemoveFromChtZone<'a> {
    type Inner = RemoveFromChtZone<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RemoveFromChtZone<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RemoveFromChtZone { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RemoveFromChtZoneArgs,
    ) -> flatbuffers::WIPOffset<RemoveFromChtZone<'bldr>> {
        let mut builder = RemoveFromChtZoneBuilder::new(_fbb);
        builder.add_zone(args.zone);
        builder.finish()
    }

    pub const VT_ZONE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn zone(&self) -> u32 {
        self._tab
            .get::<u32>(RemoveFromChtZone::VT_ZONE, Some(0))
            .unwrap()
    }
}

pub struct RemoveFromChtZoneArgs {
    pub zone: u32,
}
impl<'a> Default for RemoveFromChtZoneArgs {
    #[inline]
    fn default() -> Self {
        RemoveFromChtZoneArgs { zone: 0 }
    }
}
pub struct RemoveFromChtZoneBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RemoveFromChtZoneBuilder<'a, 'b> {
    #[inline]
    pub fn add_zone(&mut self, zone: u32) {
        self.fbb_
            .push_slot::<u32>(RemoveFromChtZone::VT_ZONE, zone, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> RemoveFromChtZoneBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RemoveFromChtZoneBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RemoveFromChtZone<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EnableRadioOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EnableRadio<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnableRadio<'a> {
    type Inner = EnableRadio<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EnableRadio<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EnableRadio { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EnableRadioArgs<'args>,
    ) -> flatbuffers::WIPOffset<EnableRadio<'bldr>> {
        let mut builder = EnableRadioBuilder::new(_fbb);
        if let Some(x) = args.uci_name {
            builder.add_uci_name(x);
        }
        builder.finish()
    }

    pub const VT_UCI_NAME: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EnableRadio::VT_UCI_NAME, None)
    }
}

pub struct EnableRadioArgs<'a> {
    pub uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EnableRadioArgs<'a> {
    #[inline]
    fn default() -> Self {
        EnableRadioArgs { uci_name: None }
    }
}
pub struct EnableRadioBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnableRadioBuilder<'a, 'b> {
    #[inline]
    pub fn add_uci_name(&mut self, uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EnableRadio::VT_UCI_NAME, uci_name);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnableRadioBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EnableRadioBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EnableRadio<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum DisableRadioOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DisableRadio<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DisableRadio<'a> {
    type Inner = DisableRadio<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DisableRadio<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DisableRadio { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DisableRadioArgs<'args>,
    ) -> flatbuffers::WIPOffset<DisableRadio<'bldr>> {
        let mut builder = DisableRadioBuilder::new(_fbb);
        if let Some(x) = args.uci_name {
            builder.add_uci_name(x);
        }
        builder.finish()
    }

    pub const VT_UCI_NAME: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(DisableRadio::VT_UCI_NAME, None)
    }
}

pub struct DisableRadioArgs<'a> {
    pub uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DisableRadioArgs<'a> {
    #[inline]
    fn default() -> Self {
        DisableRadioArgs { uci_name: None }
    }
}
pub struct DisableRadioBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DisableRadioBuilder<'a, 'b> {
    #[inline]
    pub fn add_uci_name(&mut self, uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DisableRadio::VT_UCI_NAME, uci_name);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DisableRadioBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DisableRadioBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DisableRadio<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum SetChannelOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetChannel<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetChannel<'a> {
    type Inner = SetChannel<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetChannel<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetChannel { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetChannelArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetChannel<'bldr>> {
        let mut builder = SetChannelBuilder::new(_fbb);
        if let Some(x) = args.uci_name {
            builder.add_uci_name(x);
        }
        builder.add_channel(args.channel);
        builder.finish()
    }

    pub const VT_UCI_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_CHANNEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetChannel::VT_UCI_NAME, None)
    }
    #[inline]
    pub fn channel(&self) -> u8 {
        self._tab
            .get::<u8>(SetChannel::VT_CHANNEL, Some(0))
            .unwrap()
    }
}

pub struct SetChannelArgs<'a> {
    pub uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub channel: u8,
}
impl<'a> Default for SetChannelArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetChannelArgs {
            uci_name: None,
            channel: 0,
        }
    }
}
pub struct SetChannelBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetChannelBuilder<'a, 'b> {
    #[inline]
    pub fn add_uci_name(&mut self, uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetChannel::VT_UCI_NAME, uci_name);
    }
    #[inline]
    pub fn add_channel(&mut self, channel: u8) {
        self.fbb_
            .push_slot::<u8>(SetChannel::VT_CHANNEL, channel, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetChannelBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetChannelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetChannel<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum SetOpModeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetOpMode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetOpMode<'a> {
    type Inner = SetOpMode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetOpMode<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetOpMode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetOpModeArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetOpMode<'bldr>> {
        let mut builder = SetOpModeBuilder::new(_fbb);
        if let Some(x) = args.hwmode {
            builder.add_hwmode(x);
        }
        if let Some(x) = args.htmode {
            builder.add_htmode(x);
        }
        if let Some(x) = args.uci_name {
            builder.add_uci_name(x);
        }
        builder.add_disable_b(args.disable_b);
        builder.finish()
    }

    pub const VT_UCI_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_HTMODE: flatbuffers::VOffsetT = 6;
    pub const VT_HWMODE: flatbuffers::VOffsetT = 8;
    pub const VT_DISABLE_B: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetOpMode::VT_UCI_NAME, None)
    }
    #[inline]
    pub fn htmode(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetOpMode::VT_HTMODE, None)
    }
    #[inline]
    pub fn hwmode(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetOpMode::VT_HWMODE, None)
    }
    #[inline]
    pub fn disable_b(&self) -> u8 {
        self._tab
            .get::<u8>(SetOpMode::VT_DISABLE_B, Some(0))
            .unwrap()
    }
}

pub struct SetOpModeArgs<'a> {
    pub uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub htmode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hwmode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub disable_b: u8,
}
impl<'a> Default for SetOpModeArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetOpModeArgs {
            uci_name: None,
            htmode: None,
            hwmode: None,
            disable_b: 0,
        }
    }
}
pub struct SetOpModeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetOpModeBuilder<'a, 'b> {
    #[inline]
    pub fn add_uci_name(&mut self, uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetOpMode::VT_UCI_NAME, uci_name);
    }
    #[inline]
    pub fn add_htmode(&mut self, htmode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetOpMode::VT_HTMODE, htmode);
    }
    #[inline]
    pub fn add_hwmode(&mut self, hwmode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetOpMode::VT_HWMODE, hwmode);
    }
    #[inline]
    pub fn add_disable_b(&mut self, disable_b: u8) {
        self.fbb_
            .push_slot::<u8>(SetOpMode::VT_DISABLE_B, disable_b, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetOpModeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetOpModeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetOpMode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum CreateVradioOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CreateVradio<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateVradio<'a> {
    type Inner = CreateVradio<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CreateVradio<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CreateVradio { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CreateVradioArgs<'args>,
    ) -> flatbuffers::WIPOffset<CreateVradio<'bldr>> {
        let mut builder = CreateVradioBuilder::new(_fbb);
        if let Some(x) = args.network_name {
            builder.add_network_name(x);
        }
        if let Some(x) = args.encryption {
            builder.add_encryption(x);
        }
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_uci_name {
            builder.add_phy_uci_name(x);
        }
        builder.add_thr_max(args.thr_max);
        builder.add_thr_min(args.thr_min);
        builder.add_tc(args.tc);
        builder.add_pre(args.pre);
        builder.add_sr(args.sr);
        builder.add_lb(args.lb);
        builder.add_isolate(args.isolate);
        builder.add_hidden(args.hidden);
        builder.add_encryption_type(args.encryption_type);
        builder.finish()
    }

    pub const VT_PHY_UCI_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SSID: flatbuffers::VOffsetT = 6;
    pub const VT_ENCRYPTION_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_ENCRYPTION: flatbuffers::VOffsetT = 10;
    pub const VT_NETWORK_NAME: flatbuffers::VOffsetT = 12;
    pub const VT_HIDDEN: flatbuffers::VOffsetT = 14;
    pub const VT_ISOLATE: flatbuffers::VOffsetT = 16;
    pub const VT_LB: flatbuffers::VOffsetT = 18;
    pub const VT_SR: flatbuffers::VOffsetT = 20;
    pub const VT_PRE: flatbuffers::VOffsetT = 22;
    pub const VT_TC: flatbuffers::VOffsetT = 24;
    pub const VT_THR_MIN: flatbuffers::VOffsetT = 26;
    pub const VT_THR_MAX: flatbuffers::VOffsetT = 28;

    #[inline]
    pub fn phy_uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CreateVradio::VT_PHY_UCI_NAME, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CreateVradio::VT_SSID, None)
    }
    #[inline]
    pub fn encryption_type(&self) -> Encryption {
        self._tab
            .get::<Encryption>(CreateVradio::VT_ENCRYPTION_TYPE, Some(Encryption::NONE))
            .unwrap()
    }
    #[inline]
    pub fn encryption(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                CreateVradio::VT_ENCRYPTION,
                None,
            )
    }
    #[inline]
    pub fn network_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(CreateVradio::VT_NETWORK_NAME, None)
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        self._tab
            .get::<u8>(CreateVradio::VT_HIDDEN, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn isolate(&self) -> u8 {
        self._tab
            .get::<u8>(CreateVradio::VT_ISOLATE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn lb(&self) -> u8 {
        self._tab.get::<u8>(CreateVradio::VT_LB, Some(0)).unwrap()
    }
    #[inline]
    pub fn sr(&self) -> u8 {
        self._tab.get::<u8>(CreateVradio::VT_SR, Some(0)).unwrap()
    }
    #[inline]
    pub fn pre(&self) -> u8 {
        self._tab.get::<u8>(CreateVradio::VT_PRE, Some(0)).unwrap()
    }
    #[inline]
    pub fn tc(&self) -> u8 {
        self._tab.get::<u8>(CreateVradio::VT_TC, Some(0)).unwrap()
    }
    #[inline]
    pub fn thr_min(&self) -> u16 {
        self._tab
            .get::<u16>(CreateVradio::VT_THR_MIN, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn thr_max(&self) -> u16 {
        self._tab
            .get::<u16>(CreateVradio::VT_THR_MAX, Some(0))
            .unwrap()
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_none(&self) -> Option<EncNone<'a>> {
        if self.encryption_type() == Encryption::EncNone {
            self.encryption().map(|u| EncNone::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_psk(&self) -> Option<EncPsk<'a>> {
        if self.encryption_type() == Encryption::EncPsk {
            self.encryption().map(|u| EncPsk::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_psk_2(&self) -> Option<EncPsk2<'a>> {
        if self.encryption_type() == Encryption::EncPsk2 {
            self.encryption().map(|u| EncPsk2::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_psk_mixed(&self) -> Option<EncPskMixed<'a>> {
        if self.encryption_type() == Encryption::EncPskMixed {
            self.encryption().map(|u| EncPskMixed::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wep(&self) -> Option<EncWep<'a>> {
        if self.encryption_type() == Encryption::EncWep {
            self.encryption().map(|u| EncWep::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wpa(&self) -> Option<EncWpa<'a>> {
        if self.encryption_type() == Encryption::EncWpa {
            self.encryption().map(|u| EncWpa::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wpa_2(&self) -> Option<EncWpa2<'a>> {
        if self.encryption_type() == Encryption::EncWpa2 {
            self.encryption().map(|u| EncWpa2::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn encryption_as_enc_wpa_mixed(&self) -> Option<EncWpaMixed<'a>> {
        if self.encryption_type() == Encryption::EncWpaMixed {
            self.encryption().map(|u| EncWpaMixed::init_from_table(u))
        } else {
            None
        }
    }
}

pub struct CreateVradioArgs<'a> {
    pub phy_uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encryption_type: Encryption,
    pub encryption: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub network_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hidden: u8,
    pub isolate: u8,
    pub lb: u8,
    pub sr: u8,
    pub pre: u8,
    pub tc: u8,
    pub thr_min: u16,
    pub thr_max: u16,
}
impl<'a> Default for CreateVradioArgs<'a> {
    #[inline]
    fn default() -> Self {
        CreateVradioArgs {
            phy_uci_name: None,
            ssid: None,
            encryption_type: Encryption::NONE,
            encryption: None,
            network_name: None,
            hidden: 0,
            isolate: 0,
            lb: 0,
            sr: 0,
            pre: 0,
            tc: 0,
            thr_min: 0,
            thr_max: 0,
        }
    }
}
pub struct CreateVradioBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateVradioBuilder<'a, 'b> {
    #[inline]
    pub fn add_phy_uci_name(&mut self, phy_uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            CreateVradio::VT_PHY_UCI_NAME,
            phy_uci_name,
        );
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CreateVradio::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_encryption_type(&mut self, encryption_type: Encryption) {
        self.fbb_.push_slot::<Encryption>(
            CreateVradio::VT_ENCRYPTION_TYPE,
            encryption_type,
            Encryption::NONE,
        );
    }
    #[inline]
    pub fn add_encryption(
        &mut self,
        encryption: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CreateVradio::VT_ENCRYPTION, encryption);
    }
    #[inline]
    pub fn add_network_name(&mut self, network_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            CreateVradio::VT_NETWORK_NAME,
            network_name,
        );
    }
    #[inline]
    pub fn add_hidden(&mut self, hidden: u8) {
        self.fbb_
            .push_slot::<u8>(CreateVradio::VT_HIDDEN, hidden, 0);
    }
    #[inline]
    pub fn add_isolate(&mut self, isolate: u8) {
        self.fbb_
            .push_slot::<u8>(CreateVradio::VT_ISOLATE, isolate, 0);
    }
    #[inline]
    pub fn add_lb(&mut self, lb: u8) {
        self.fbb_.push_slot::<u8>(CreateVradio::VT_LB, lb, 0);
    }
    #[inline]
    pub fn add_sr(&mut self, sr: u8) {
        self.fbb_.push_slot::<u8>(CreateVradio::VT_SR, sr, 0);
    }
    #[inline]
    pub fn add_pre(&mut self, pre: u8) {
        self.fbb_.push_slot::<u8>(CreateVradio::VT_PRE, pre, 0);
    }
    #[inline]
    pub fn add_tc(&mut self, tc: u8) {
        self.fbb_.push_slot::<u8>(CreateVradio::VT_TC, tc, 0);
    }
    #[inline]
    pub fn add_thr_min(&mut self, thr_min: u16) {
        self.fbb_
            .push_slot::<u16>(CreateVradio::VT_THR_MIN, thr_min, 0);
    }
    #[inline]
    pub fn add_thr_max(&mut self, thr_max: u16) {
        self.fbb_
            .push_slot::<u16>(CreateVradio::VT_THR_MAX, thr_max, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CreateVradioBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CreateVradioBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CreateVradio<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum RemoveVradioOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RemoveVradio<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RemoveVradio<'a> {
    type Inner = RemoveVradio<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RemoveVradio<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RemoveVradio { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RemoveVradioArgs<'args>,
    ) -> flatbuffers::WIPOffset<RemoveVradio<'bldr>> {
        let mut builder = RemoveVradioBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_uci_name {
            builder.add_phy_uci_name(x);
        }
        builder.finish()
    }

    pub const VT_PHY_UCI_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SSID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn phy_uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RemoveVradio::VT_PHY_UCI_NAME, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RemoveVradio::VT_SSID, None)
    }
}

pub struct RemoveVradioArgs<'a> {
    pub phy_uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RemoveVradioArgs<'a> {
    #[inline]
    fn default() -> Self {
        RemoveVradioArgs {
            phy_uci_name: None,
            ssid: None,
        }
    }
}
pub struct RemoveVradioBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RemoveVradioBuilder<'a, 'b> {
    #[inline]
    pub fn add_phy_uci_name(&mut self, phy_uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RemoveVradio::VT_PHY_UCI_NAME,
            phy_uci_name,
        );
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RemoveVradio::VT_SSID, ssid);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RemoveVradioBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RemoveVradioBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RemoveVradio<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum SetPowerOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetPower<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetPower<'a> {
    type Inner = SetPower<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetPower<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetPower { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetPowerArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetPower<'bldr>> {
        let mut builder = SetPowerBuilder::new(_fbb);
        if let Some(x) = args.uci_name {
            builder.add_uci_name(x);
        }
        builder.add_power(args.power);
        builder.finish()
    }

    pub const VT_UCI_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_POWER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetPower::VT_UCI_NAME, None)
    }
    #[inline]
    pub fn power(&self) -> i8 {
        self._tab.get::<i8>(SetPower::VT_POWER, Some(0)).unwrap()
    }
}

pub struct SetPowerArgs<'a> {
    pub uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub power: i8,
}
impl<'a> Default for SetPowerArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetPowerArgs {
            uci_name: None,
            power: 0,
        }
    }
}
pub struct SetPowerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetPowerBuilder<'a, 'b> {
    #[inline]
    pub fn add_uci_name(&mut self, uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPower::VT_UCI_NAME, uci_name);
    }
    #[inline]
    pub fn add_power(&mut self, power: i8) {
        self.fbb_.push_slot::<i8>(SetPower::VT_POWER, power, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetPowerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetPowerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetPower<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum TcEnableOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TcEnable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TcEnable<'a> {
    type Inner = TcEnable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TcEnable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TcEnable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TcEnableArgs<'args>,
    ) -> flatbuffers::WIPOffset<TcEnable<'bldr>> {
        let mut builder = TcEnableBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_uci_name {
            builder.add_phy_uci_name(x);
        }
        builder.add_thr_max(args.thr_max);
        builder.add_thr_min(args.thr_min);
        builder.finish()
    }

    pub const VT_PHY_UCI_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SSID: flatbuffers::VOffsetT = 6;
    pub const VT_THR_MIN: flatbuffers::VOffsetT = 8;
    pub const VT_THR_MAX: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn phy_uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TcEnable::VT_PHY_UCI_NAME, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TcEnable::VT_SSID, None)
    }
    #[inline]
    pub fn thr_min(&self) -> u16 {
        self._tab.get::<u16>(TcEnable::VT_THR_MIN, Some(0)).unwrap()
    }
    #[inline]
    pub fn thr_max(&self) -> u16 {
        self._tab.get::<u16>(TcEnable::VT_THR_MAX, Some(0)).unwrap()
    }
}

pub struct TcEnableArgs<'a> {
    pub phy_uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub thr_min: u16,
    pub thr_max: u16,
}
impl<'a> Default for TcEnableArgs<'a> {
    #[inline]
    fn default() -> Self {
        TcEnableArgs {
            phy_uci_name: None,
            ssid: None,
            thr_min: 0,
            thr_max: 0,
        }
    }
}
pub struct TcEnableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TcEnableBuilder<'a, 'b> {
    #[inline]
    pub fn add_phy_uci_name(&mut self, phy_uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TcEnable::VT_PHY_UCI_NAME, phy_uci_name);
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TcEnable::VT_SSID, ssid);
    }
    #[inline]
    pub fn add_thr_min(&mut self, thr_min: u16) {
        self.fbb_.push_slot::<u16>(TcEnable::VT_THR_MIN, thr_min, 0);
    }
    #[inline]
    pub fn add_thr_max(&mut self, thr_max: u16) {
        self.fbb_.push_slot::<u16>(TcEnable::VT_THR_MAX, thr_max, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TcEnableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TcEnableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TcEnable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum TcDisableOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TcDisable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TcDisable<'a> {
    type Inner = TcDisable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TcDisable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TcDisable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TcDisableArgs<'args>,
    ) -> flatbuffers::WIPOffset<TcDisable<'bldr>> {
        let mut builder = TcDisableBuilder::new(_fbb);
        if let Some(x) = args.ssid {
            builder.add_ssid(x);
        }
        if let Some(x) = args.phy_uci_name {
            builder.add_phy_uci_name(x);
        }
        builder.finish()
    }

    pub const VT_PHY_UCI_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SSID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn phy_uci_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TcDisable::VT_PHY_UCI_NAME, None)
    }
    #[inline]
    pub fn ssid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TcDisable::VT_SSID, None)
    }
}

pub struct TcDisableArgs<'a> {
    pub phy_uci_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ssid: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TcDisableArgs<'a> {
    #[inline]
    fn default() -> Self {
        TcDisableArgs {
            phy_uci_name: None,
            ssid: None,
        }
    }
}
pub struct TcDisableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TcDisableBuilder<'a, 'b> {
    #[inline]
    pub fn add_phy_uci_name(&mut self, phy_uci_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TcDisable::VT_PHY_UCI_NAME,
            phy_uci_name,
        );
    }
    #[inline]
    pub fn add_ssid(&mut self, ssid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TcDisable::VT_SSID, ssid);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TcDisableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TcDisableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TcDisable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum AcaEnableOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AcaEnable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AcaEnable<'a> {
    type Inner = AcaEnable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AcaEnable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AcaEnable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args AcaEnableArgs,
    ) -> flatbuffers::WIPOffset<AcaEnable<'bldr>> {
        let mut builder = AcaEnableBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct AcaEnableArgs {}
impl<'a> Default for AcaEnableArgs {
    #[inline]
    fn default() -> Self {
        AcaEnableArgs {}
    }
}
pub struct AcaEnableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AcaEnableBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AcaEnableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AcaEnableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AcaEnable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum AcaDisableOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AcaDisable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AcaDisable<'a> {
    type Inner = AcaDisable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AcaDisable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AcaDisable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args AcaDisableArgs,
    ) -> flatbuffers::WIPOffset<AcaDisable<'bldr>> {
        let mut builder = AcaDisableBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct AcaDisableArgs {}
impl<'a> Default for AcaDisableArgs {
    #[inline]
    fn default() -> Self {
        AcaDisableArgs {}
    }
}
pub struct AcaDisableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AcaDisableBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AcaDisableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AcaDisableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AcaDisable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum LocSetMyPosOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct LocSetMyPos<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LocSetMyPos<'a> {
    type Inner = LocSetMyPos<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> LocSetMyPos<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LocSetMyPos { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LocSetMyPosArgs<'args>,
    ) -> flatbuffers::WIPOffset<LocSetMyPos<'bldr>> {
        let mut builder = LocSetMyPosBuilder::new(_fbb);
        builder.add_group(args.group);
        if let Some(x) = args.loc {
            builder.add_loc(x);
        }
        builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_GROUP: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn loc(&self) -> Option<&'a Loc3Float> {
        self._tab.get::<Loc3Float>(LocSetMyPos::VT_LOC, None)
    }
    #[inline]
    pub fn group(&self) -> u32 {
        self._tab
            .get::<u32>(LocSetMyPos::VT_GROUP, Some(0))
            .unwrap()
    }
}

pub struct LocSetMyPosArgs<'a> {
    pub loc: Option<&'a Loc3Float>,
    pub group: u32,
}
impl<'a> Default for LocSetMyPosArgs<'a> {
    #[inline]
    fn default() -> Self {
        LocSetMyPosArgs {
            loc: None,
            group: 0,
        }
    }
}
pub struct LocSetMyPosBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LocSetMyPosBuilder<'a, 'b> {
    #[inline]
    pub fn add_loc(&mut self, loc: &'b Loc3Float) {
        self.fbb_
            .push_slot_always::<&Loc3Float>(LocSetMyPos::VT_LOC, loc);
    }
    #[inline]
    pub fn add_group(&mut self, group: u32) {
        self.fbb_.push_slot::<u32>(LocSetMyPos::VT_GROUP, group, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LocSetMyPosBuilder<'a, 'b> {
        let start = _fbb.start_table();
        LocSetMyPosBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LocSetMyPos<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum LocRemoveMyPosOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct LocRemoveMyPos<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LocRemoveMyPos<'a> {
    type Inner = LocRemoveMyPos<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> LocRemoveMyPos<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LocRemoveMyPos { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args LocRemoveMyPosArgs,
    ) -> flatbuffers::WIPOffset<LocRemoveMyPos<'bldr>> {
        let mut builder = LocRemoveMyPosBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct LocRemoveMyPosArgs {}
impl<'a> Default for LocRemoveMyPosArgs {
    #[inline]
    fn default() -> Self {
        LocRemoveMyPosArgs {}
    }
}
pub struct LocRemoveMyPosBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LocRemoveMyPosBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LocRemoveMyPosBuilder<'a, 'b> {
        let start = _fbb.start_table();
        LocRemoveMyPosBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LocRemoveMyPos<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum FlashOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Flash<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Flash<'a> {
    type Inner = Flash<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Flash<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Flash { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FlashArgs,
    ) -> flatbuffers::WIPOffset<Flash<'bldr>> {
        let mut builder = FlashBuilder::new(_fbb);
        builder.add_keep(args.keep);
        builder.finish()
    }

    pub const VT_KEEP: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn keep(&self) -> u8 {
        self._tab.get::<u8>(Flash::VT_KEEP, Some(1)).unwrap()
    }
}

pub struct FlashArgs {
    pub keep: u8,
}
impl<'a> Default for FlashArgs {
    #[inline]
    fn default() -> Self {
        FlashArgs { keep: 1 }
    }
}
pub struct FlashBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FlashBuilder<'a, 'b> {
    #[inline]
    pub fn add_keep(&mut self, keep: u8) {
        self.fbb_.push_slot::<u8>(Flash::VT_KEEP, keep, 1);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FlashBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FlashBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Flash<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum BackupOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Backup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Backup<'a> {
    type Inner = Backup<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Backup<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Backup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args BackupArgs,
    ) -> flatbuffers::WIPOffset<Backup<'bldr>> {
        let mut builder = BackupBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct BackupArgs {}
impl<'a> Default for BackupArgs {
    #[inline]
    fn default() -> Self {
        BackupArgs {}
    }
}
pub struct BackupBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BackupBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BackupBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BackupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Backup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum RestoreOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Restore<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Restore<'a> {
    type Inner = Restore<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Restore<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Restore { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RestoreArgs,
    ) -> flatbuffers::WIPOffset<Restore<'bldr>> {
        let mut builder = RestoreBuilder::new(_fbb);
        builder.add_netmask(args.netmask);
        builder.add_ip(args.ip);
        builder.finish()
    }

    pub const VT_IP: flatbuffers::VOffsetT = 4;
    pub const VT_NETMASK: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn ip(&self) -> u32 {
        self._tab.get::<u32>(Restore::VT_IP, Some(0)).unwrap()
    }
    #[inline]
    pub fn netmask(&self) -> u32 {
        self._tab.get::<u32>(Restore::VT_NETMASK, Some(0)).unwrap()
    }
}

pub struct RestoreArgs {
    pub ip: u32,
    pub netmask: u32,
}
impl<'a> Default for RestoreArgs {
    #[inline]
    fn default() -> Self {
        RestoreArgs { ip: 0, netmask: 0 }
    }
}
pub struct RestoreBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RestoreBuilder<'a, 'b> {
    #[inline]
    pub fn add_ip(&mut self, ip: u32) {
        self.fbb_.push_slot::<u32>(Restore::VT_IP, ip, 0);
    }
    #[inline]
    pub fn add_netmask(&mut self, netmask: u32) {
        self.fbb_.push_slot::<u32>(Restore::VT_NETMASK, netmask, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RestoreBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RestoreBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Restore<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum SetReportCrashesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetReportCrashes<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetReportCrashes<'a> {
    type Inner = SetReportCrashes<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetReportCrashes<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetReportCrashes { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetReportCrashesArgs,
    ) -> flatbuffers::WIPOffset<SetReportCrashes<'bldr>> {
        let mut builder = SetReportCrashesBuilder::new(_fbb);
        builder.add_enable(args.enable);
        builder.finish()
    }

    pub const VT_ENABLE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn enable(&self) -> u8 {
        self._tab
            .get::<u8>(SetReportCrashes::VT_ENABLE, Some(0))
            .unwrap()
    }
}

pub struct SetReportCrashesArgs {
    pub enable: u8,
}
impl<'a> Default for SetReportCrashesArgs {
    #[inline]
    fn default() -> Self {
        SetReportCrashesArgs { enable: 0 }
    }
}
pub struct SetReportCrashesBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetReportCrashesBuilder<'a, 'b> {
    #[inline]
    pub fn add_enable(&mut self, enable: u8) {
        self.fbb_
            .push_slot::<u8>(SetReportCrashes::VT_ENABLE, enable, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> SetReportCrashesBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetReportCrashesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetReportCrashes<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}
