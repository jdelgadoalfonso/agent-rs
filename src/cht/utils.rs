// automatically generated by the FlatBuffers compiler, do not modify

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Encryption {
    NONE = 0,
    EncNone = 1,
    EncPsk = 2,
    EncPsk2 = 3,
    EncPskMixed = 4,
    EncWep = 5,
    EncWpa = 6,
    EncWpa2 = 7,
    EncWpaMixed = 8,
}

const ENUM_MIN_ENCRYPTION: u8 = 0;
const ENUM_MAX_ENCRYPTION: u8 = 8;

impl<'a> flatbuffers::Follow<'a> for Encryption {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for Encryption {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const Encryption;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const Encryption;
        unsafe { *p }
    }
}

impl flatbuffers::Push for Encryption {
    type Output = Encryption;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Encryption>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ENCRYPTION: [Encryption; 9] = [
    Encryption::NONE,
    Encryption::EncNone,
    Encryption::EncPsk,
    Encryption::EncPsk2,
    Encryption::EncPskMixed,
    Encryption::EncWep,
    Encryption::EncWpa,
    Encryption::EncWpa2,
    Encryption::EncWpaMixed,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ENCRYPTION: [&'static str; 9] = [
    "NONE",
    "EncNone",
    "EncPsk",
    "EncPsk2",
    "EncPskMixed",
    "EncWep",
    "EncWpa",
    "EncWpa2",
    "EncWpaMixed",
];

pub fn enum_name_encryption(e: Encryption) -> &'static str {
    let index = e as u8;
    ENUM_NAMES_ENCRYPTION[index as usize]
}

pub struct EncryptionUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Ciphers {
    Ccmp = 0,
    Tkip = 1,
    TkipCcmp = 2,
}

const ENUM_MIN_CIPHERS: u8 = 0;
const ENUM_MAX_CIPHERS: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for Ciphers {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for Ciphers {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const Ciphers;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const Ciphers;
        unsafe { *p }
    }
}

impl flatbuffers::Push for Ciphers {
    type Output = Ciphers;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Ciphers>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_CIPHERS: [Ciphers; 3] = [Ciphers::Ccmp, Ciphers::Tkip, Ciphers::TkipCcmp];

#[allow(non_camel_case_types)]
const ENUM_NAMES_CIPHERS: [&'static str; 3] = ["Ccmp", "Tkip", "TkipCcmp"];

pub fn enum_name_ciphers(e: Ciphers) -> &'static str {
    let index = e as u8;
    ENUM_NAMES_CIPHERS[index as usize]
}

// struct Loc3Float, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Loc3Float {
    x_: f32,
    y_: f32,
    z_: f32,
} // pub struct Loc3Float
impl flatbuffers::SafeSliceAccess for Loc3Float {}
impl<'a> flatbuffers::Follow<'a> for Loc3Float {
    type Inner = &'a Loc3Float;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Loc3Float>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Loc3Float {
    type Inner = &'a Loc3Float;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Loc3Float>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Loc3Float {
    type Output = Loc3Float;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Loc3Float as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Loc3Float {
    type Output = Loc3Float;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Loc3Float as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl Loc3Float {
    pub fn new<'a>(_x: f32, _y: f32, _z: f32) -> Self {
        Loc3Float {
            x_: _x.to_little_endian(),
            y_: _y.to_little_endian(),
            z_: _z.to_little_endian(),
        }
    }
    pub fn x<'a>(&'a self) -> f32 {
        self.x_.from_little_endian()
    }
    pub fn y<'a>(&'a self) -> f32 {
        self.y_.from_little_endian()
    }
    pub fn z<'a>(&'a self) -> f32 {
        self.z_.from_little_endian()
    }
}

pub enum EncNoneOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncNone<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncNone<'a> {
    type Inner = EncNone<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncNone<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncNone { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args EncNoneArgs,
    ) -> flatbuffers::WIPOffset<EncNone<'bldr>> {
        let mut builder = EncNoneBuilder::new(_fbb);
        builder.finish()
    }
}

pub struct EncNoneArgs {}
impl<'a> Default for EncNoneArgs {
    #[inline]
    fn default() -> Self {
        EncNoneArgs {}
    }
}
pub struct EncNoneBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncNoneBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncNoneBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EncNoneBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncNone<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EncWepOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncWep<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncWep<'a> {
    type Inner = EncWep<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncWep<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncWep { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EncWepArgs<'args>,
    ) -> flatbuffers::WIPOffset<EncWep<'bldr>> {
        let mut builder = EncWepBuilder::new(_fbb);
        if let Some(x) = args.password {
            builder.add_password(x);
        }
        builder.finish()
    }

    pub const VT_PASSWORD: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn password(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EncWep::VT_PASSWORD, None)
    }
}

pub struct EncWepArgs<'a> {
    pub password: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EncWepArgs<'a> {
    #[inline]
    fn default() -> Self {
        EncWepArgs { password: None }
    }
}
pub struct EncWepBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncWepBuilder<'a, 'b> {
    #[inline]
    pub fn add_password(&mut self, password: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EncWep::VT_PASSWORD, password);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncWepBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EncWepBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncWep<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EncPskOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncPsk<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncPsk<'a> {
    type Inner = EncPsk<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncPsk<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncPsk { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EncPskArgs<'args>,
    ) -> flatbuffers::WIPOffset<EncPsk<'bldr>> {
        let mut builder = EncPskBuilder::new(_fbb);
        if let Some(x) = args.password {
            builder.add_password(x);
        }
        builder.add_cipher(args.cipher);
        builder.finish()
    }

    pub const VT_PASSWORD: flatbuffers::VOffsetT = 4;
    pub const VT_CIPHER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn password(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EncPsk::VT_PASSWORD, None)
    }
    #[inline]
    pub fn cipher(&self) -> Ciphers {
        self._tab
            .get::<Ciphers>(EncPsk::VT_CIPHER, Some(Ciphers::Ccmp))
            .unwrap()
    }
}

pub struct EncPskArgs<'a> {
    pub password: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cipher: Ciphers,
}
impl<'a> Default for EncPskArgs<'a> {
    #[inline]
    fn default() -> Self {
        EncPskArgs {
            password: None,
            cipher: Ciphers::Ccmp,
        }
    }
}
pub struct EncPskBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncPskBuilder<'a, 'b> {
    #[inline]
    pub fn add_password(&mut self, password: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EncPsk::VT_PASSWORD, password);
    }
    #[inline]
    pub fn add_cipher(&mut self, cipher: Ciphers) {
        self.fbb_
            .push_slot::<Ciphers>(EncPsk::VT_CIPHER, cipher, Ciphers::Ccmp);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncPskBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EncPskBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncPsk<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EncPsk2Offset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncPsk2<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncPsk2<'a> {
    type Inner = EncPsk2<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncPsk2<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncPsk2 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EncPsk2Args<'args>,
    ) -> flatbuffers::WIPOffset<EncPsk2<'bldr>> {
        let mut builder = EncPsk2Builder::new(_fbb);
        if let Some(x) = args.password {
            builder.add_password(x);
        }
        builder.add_cipher(args.cipher);
        builder.finish()
    }

    pub const VT_PASSWORD: flatbuffers::VOffsetT = 4;
    pub const VT_CIPHER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn password(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EncPsk2::VT_PASSWORD, None)
    }
    #[inline]
    pub fn cipher(&self) -> Ciphers {
        self._tab
            .get::<Ciphers>(EncPsk2::VT_CIPHER, Some(Ciphers::Ccmp))
            .unwrap()
    }
}

pub struct EncPsk2Args<'a> {
    pub password: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cipher: Ciphers,
}
impl<'a> Default for EncPsk2Args<'a> {
    #[inline]
    fn default() -> Self {
        EncPsk2Args {
            password: None,
            cipher: Ciphers::Ccmp,
        }
    }
}
pub struct EncPsk2Builder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncPsk2Builder<'a, 'b> {
    #[inline]
    pub fn add_password(&mut self, password: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EncPsk2::VT_PASSWORD, password);
    }
    #[inline]
    pub fn add_cipher(&mut self, cipher: Ciphers) {
        self.fbb_
            .push_slot::<Ciphers>(EncPsk2::VT_CIPHER, cipher, Ciphers::Ccmp);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncPsk2Builder<'a, 'b> {
        let start = _fbb.start_table();
        EncPsk2Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncPsk2<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EncPskMixedOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncPskMixed<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncPskMixed<'a> {
    type Inner = EncPskMixed<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncPskMixed<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncPskMixed { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EncPskMixedArgs<'args>,
    ) -> flatbuffers::WIPOffset<EncPskMixed<'bldr>> {
        let mut builder = EncPskMixedBuilder::new(_fbb);
        if let Some(x) = args.password {
            builder.add_password(x);
        }
        builder.add_cipher(args.cipher);
        builder.finish()
    }

    pub const VT_PASSWORD: flatbuffers::VOffsetT = 4;
    pub const VT_CIPHER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn password(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EncPskMixed::VT_PASSWORD, None)
    }
    #[inline]
    pub fn cipher(&self) -> Ciphers {
        self._tab
            .get::<Ciphers>(EncPskMixed::VT_CIPHER, Some(Ciphers::Ccmp))
            .unwrap()
    }
}

pub struct EncPskMixedArgs<'a> {
    pub password: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cipher: Ciphers,
}
impl<'a> Default for EncPskMixedArgs<'a> {
    #[inline]
    fn default() -> Self {
        EncPskMixedArgs {
            password: None,
            cipher: Ciphers::Ccmp,
        }
    }
}
pub struct EncPskMixedBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncPskMixedBuilder<'a, 'b> {
    #[inline]
    pub fn add_password(&mut self, password: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EncPskMixed::VT_PASSWORD, password);
    }
    #[inline]
    pub fn add_cipher(&mut self, cipher: Ciphers) {
        self.fbb_
            .push_slot::<Ciphers>(EncPskMixed::VT_CIPHER, cipher, Ciphers::Ccmp);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncPskMixedBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EncPskMixedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncPskMixed<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EncWpaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncWpa<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncWpa<'a> {
    type Inner = EncWpa<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncWpa<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncWpa { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EncWpaArgs<'args>,
    ) -> flatbuffers::WIPOffset<EncWpa<'bldr>> {
        let mut builder = EncWpaBuilder::new(_fbb);
        if let Some(x) = args.radius_conf {
            builder.add_radius_conf(x);
        }
        builder.add_cipher(args.cipher);
        builder.finish()
    }

    pub const VT_RADIUS_CONF: flatbuffers::VOffsetT = 4;
    pub const VT_CIPHER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn radius_conf(&self) -> Option<RadiusConf<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<RadiusConf<'a>>>(EncWpa::VT_RADIUS_CONF, None)
    }
    #[inline]
    pub fn cipher(&self) -> Ciphers {
        self._tab
            .get::<Ciphers>(EncWpa::VT_CIPHER, Some(Ciphers::Ccmp))
            .unwrap()
    }
}

pub struct EncWpaArgs<'a> {
    pub radius_conf: Option<flatbuffers::WIPOffset<RadiusConf<'a>>>,
    pub cipher: Ciphers,
}
impl<'a> Default for EncWpaArgs<'a> {
    #[inline]
    fn default() -> Self {
        EncWpaArgs {
            radius_conf: None,
            cipher: Ciphers::Ccmp,
        }
    }
}
pub struct EncWpaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncWpaBuilder<'a, 'b> {
    #[inline]
    pub fn add_radius_conf(&mut self, radius_conf: flatbuffers::WIPOffset<RadiusConf<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<RadiusConf>>(
                EncWpa::VT_RADIUS_CONF,
                radius_conf,
            );
    }
    #[inline]
    pub fn add_cipher(&mut self, cipher: Ciphers) {
        self.fbb_
            .push_slot::<Ciphers>(EncWpa::VT_CIPHER, cipher, Ciphers::Ccmp);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncWpaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EncWpaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncWpa<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EncWpa2Offset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncWpa2<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncWpa2<'a> {
    type Inner = EncWpa2<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncWpa2<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncWpa2 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EncWpa2Args<'args>,
    ) -> flatbuffers::WIPOffset<EncWpa2<'bldr>> {
        let mut builder = EncWpa2Builder::new(_fbb);
        if let Some(x) = args.radius_conf {
            builder.add_radius_conf(x);
        }
        builder.add_cipher(args.cipher);
        builder.finish()
    }

    pub const VT_RADIUS_CONF: flatbuffers::VOffsetT = 4;
    pub const VT_CIPHER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn radius_conf(&self) -> Option<RadiusConf<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<RadiusConf<'a>>>(EncWpa2::VT_RADIUS_CONF, None)
    }
    #[inline]
    pub fn cipher(&self) -> Ciphers {
        self._tab
            .get::<Ciphers>(EncWpa2::VT_CIPHER, Some(Ciphers::Ccmp))
            .unwrap()
    }
}

pub struct EncWpa2Args<'a> {
    pub radius_conf: Option<flatbuffers::WIPOffset<RadiusConf<'a>>>,
    pub cipher: Ciphers,
}
impl<'a> Default for EncWpa2Args<'a> {
    #[inline]
    fn default() -> Self {
        EncWpa2Args {
            radius_conf: None,
            cipher: Ciphers::Ccmp,
        }
    }
}
pub struct EncWpa2Builder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncWpa2Builder<'a, 'b> {
    #[inline]
    pub fn add_radius_conf(&mut self, radius_conf: flatbuffers::WIPOffset<RadiusConf<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<RadiusConf>>(
                EncWpa2::VT_RADIUS_CONF,
                radius_conf,
            );
    }
    #[inline]
    pub fn add_cipher(&mut self, cipher: Ciphers) {
        self.fbb_
            .push_slot::<Ciphers>(EncWpa2::VT_CIPHER, cipher, Ciphers::Ccmp);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncWpa2Builder<'a, 'b> {
        let start = _fbb.start_table();
        EncWpa2Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncWpa2<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum EncWpaMixedOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EncWpaMixed<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncWpaMixed<'a> {
    type Inner = EncWpaMixed<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EncWpaMixed<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EncWpaMixed { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EncWpaMixedArgs<'args>,
    ) -> flatbuffers::WIPOffset<EncWpaMixed<'bldr>> {
        let mut builder = EncWpaMixedBuilder::new(_fbb);
        if let Some(x) = args.radius_conf {
            builder.add_radius_conf(x);
        }
        builder.add_cipher(args.cipher);
        builder.finish()
    }

    pub const VT_RADIUS_CONF: flatbuffers::VOffsetT = 4;
    pub const VT_CIPHER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn radius_conf(&self) -> Option<RadiusConf<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<RadiusConf<'a>>>(EncWpaMixed::VT_RADIUS_CONF, None)
    }
    #[inline]
    pub fn cipher(&self) -> Ciphers {
        self._tab
            .get::<Ciphers>(EncWpaMixed::VT_CIPHER, Some(Ciphers::Ccmp))
            .unwrap()
    }
}

pub struct EncWpaMixedArgs<'a> {
    pub radius_conf: Option<flatbuffers::WIPOffset<RadiusConf<'a>>>,
    pub cipher: Ciphers,
}
impl<'a> Default for EncWpaMixedArgs<'a> {
    #[inline]
    fn default() -> Self {
        EncWpaMixedArgs {
            radius_conf: None,
            cipher: Ciphers::Ccmp,
        }
    }
}
pub struct EncWpaMixedBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EncWpaMixedBuilder<'a, 'b> {
    #[inline]
    pub fn add_radius_conf(&mut self, radius_conf: flatbuffers::WIPOffset<RadiusConf<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<RadiusConf>>(
                EncWpaMixed::VT_RADIUS_CONF,
                radius_conf,
            );
    }
    #[inline]
    pub fn add_cipher(&mut self, cipher: Ciphers) {
        self.fbb_
            .push_slot::<Ciphers>(EncWpaMixed::VT_CIPHER, cipher, Ciphers::Ccmp);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EncWpaMixedBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EncWpaMixedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EncWpaMixed<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum RadiusConfOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RadiusConf<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RadiusConf<'a> {
    type Inner = RadiusConf<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RadiusConf<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RadiusConf { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RadiusConfArgs<'args>,
    ) -> flatbuffers::WIPOffset<RadiusConf<'bldr>> {
        let mut builder = RadiusConfBuilder::new(_fbb);
        if let Some(x) = args.dae_secret {
            builder.add_dae_secret(x);
        }
        if let Some(x) = args.dae_client {
            builder.add_dae_client(x);
        }
        if let Some(x) = args.ownip {
            builder.add_ownip(x);
        }
        if let Some(x) = args.nasid {
            builder.add_nasid(x);
        }
        builder.add_wpa_group_rekey(args.wpa_group_rekey);
        if let Some(x) = args.acct_secret {
            builder.add_acct_secret(x);
        }
        if let Some(x) = args.acct_server {
            builder.add_acct_server(x);
        }
        if let Some(x) = args.auth_secret {
            builder.add_auth_secret(x);
        }
        if let Some(x) = args.auth_server {
            builder.add_auth_server(x);
        }
        builder.add_dae_port(args.dae_port);
        builder.add_acct_port(args.acct_port);
        builder.add_auth_port(args.auth_port);
        builder.add_dynamic_vlan(args.dynamic_vlan);
        builder.add_auth_cache(args.auth_cache);
        builder.finish()
    }

    pub const VT_AUTH_SERVER: flatbuffers::VOffsetT = 4;
    pub const VT_AUTH_PORT: flatbuffers::VOffsetT = 6;
    pub const VT_AUTH_SECRET: flatbuffers::VOffsetT = 8;
    pub const VT_AUTH_CACHE: flatbuffers::VOffsetT = 10;
    pub const VT_ACCT_SERVER: flatbuffers::VOffsetT = 12;
    pub const VT_ACCT_PORT: flatbuffers::VOffsetT = 14;
    pub const VT_ACCT_SECRET: flatbuffers::VOffsetT = 16;
    pub const VT_WPA_GROUP_REKEY: flatbuffers::VOffsetT = 18;
    pub const VT_NASID: flatbuffers::VOffsetT = 20;
    pub const VT_OWNIP: flatbuffers::VOffsetT = 22;
    pub const VT_DAE_CLIENT: flatbuffers::VOffsetT = 24;
    pub const VT_DAE_PORT: flatbuffers::VOffsetT = 26;
    pub const VT_DAE_SECRET: flatbuffers::VOffsetT = 28;
    pub const VT_DYNAMIC_VLAN: flatbuffers::VOffsetT = 30;

    #[inline]
    pub fn auth_server(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_AUTH_SERVER, None)
    }
    #[inline]
    pub fn auth_port(&self) -> u16 {
        self._tab
            .get::<u16>(RadiusConf::VT_AUTH_PORT, Some(1812))
            .unwrap()
    }
    #[inline]
    pub fn auth_secret(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_AUTH_SECRET, None)
    }
    #[inline]
    pub fn auth_cache(&self) -> u8 {
        self._tab
            .get::<u8>(RadiusConf::VT_AUTH_CACHE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn acct_server(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_ACCT_SERVER, None)
    }
    #[inline]
    pub fn acct_port(&self) -> u16 {
        self._tab
            .get::<u16>(RadiusConf::VT_ACCT_PORT, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn acct_secret(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_ACCT_SECRET, None)
    }
    #[inline]
    pub fn wpa_group_rekey(&self) -> u32 {
        self._tab
            .get::<u32>(RadiusConf::VT_WPA_GROUP_REKEY, Some(600))
            .unwrap()
    }
    #[inline]
    pub fn nasid(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_NASID, None)
    }
    #[inline]
    pub fn ownip(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_OWNIP, None)
    }
    #[inline]
    pub fn dae_client(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_DAE_CLIENT, None)
    }
    #[inline]
    pub fn dae_port(&self) -> u16 {
        self._tab
            .get::<u16>(RadiusConf::VT_DAE_PORT, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn dae_secret(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RadiusConf::VT_DAE_SECRET, None)
    }
    #[inline]
    pub fn dynamic_vlan(&self) -> u8 {
        self._tab
            .get::<u8>(RadiusConf::VT_DYNAMIC_VLAN, Some(0))
            .unwrap()
    }
}

pub struct RadiusConfArgs<'a> {
    pub auth_server: Option<flatbuffers::WIPOffset<&'a str>>,
    pub auth_port: u16,
    pub auth_secret: Option<flatbuffers::WIPOffset<&'a str>>,
    pub auth_cache: u8,
    pub acct_server: Option<flatbuffers::WIPOffset<&'a str>>,
    pub acct_port: u16,
    pub acct_secret: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wpa_group_rekey: u32,
    pub nasid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ownip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dae_client: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dae_port: u16,
    pub dae_secret: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dynamic_vlan: u8,
}
impl<'a> Default for RadiusConfArgs<'a> {
    #[inline]
    fn default() -> Self {
        RadiusConfArgs {
            auth_server: None,
            auth_port: 1812,
            auth_secret: None,
            auth_cache: 0,
            acct_server: None,
            acct_port: 0,
            acct_secret: None,
            wpa_group_rekey: 600,
            nasid: None,
            ownip: None,
            dae_client: None,
            dae_port: 0,
            dae_secret: None,
            dynamic_vlan: 0,
        }
    }
}
pub struct RadiusConfBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RadiusConfBuilder<'a, 'b> {
    #[inline]
    pub fn add_auth_server(&mut self, auth_server: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_AUTH_SERVER, auth_server);
    }
    #[inline]
    pub fn add_auth_port(&mut self, auth_port: u16) {
        self.fbb_
            .push_slot::<u16>(RadiusConf::VT_AUTH_PORT, auth_port, 1812);
    }
    #[inline]
    pub fn add_auth_secret(&mut self, auth_secret: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_AUTH_SECRET, auth_secret);
    }
    #[inline]
    pub fn add_auth_cache(&mut self, auth_cache: u8) {
        self.fbb_
            .push_slot::<u8>(RadiusConf::VT_AUTH_CACHE, auth_cache, 0);
    }
    #[inline]
    pub fn add_acct_server(&mut self, acct_server: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_ACCT_SERVER, acct_server);
    }
    #[inline]
    pub fn add_acct_port(&mut self, acct_port: u16) {
        self.fbb_
            .push_slot::<u16>(RadiusConf::VT_ACCT_PORT, acct_port, 0);
    }
    #[inline]
    pub fn add_acct_secret(&mut self, acct_secret: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_ACCT_SECRET, acct_secret);
    }
    #[inline]
    pub fn add_wpa_group_rekey(&mut self, wpa_group_rekey: u32) {
        self.fbb_
            .push_slot::<u32>(RadiusConf::VT_WPA_GROUP_REKEY, wpa_group_rekey, 600);
    }
    #[inline]
    pub fn add_nasid(&mut self, nasid: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_NASID, nasid);
    }
    #[inline]
    pub fn add_ownip(&mut self, ownip: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_OWNIP, ownip);
    }
    #[inline]
    pub fn add_dae_client(&mut self, dae_client: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_DAE_CLIENT, dae_client);
    }
    #[inline]
    pub fn add_dae_port(&mut self, dae_port: u16) {
        self.fbb_
            .push_slot::<u16>(RadiusConf::VT_DAE_PORT, dae_port, 0);
    }
    #[inline]
    pub fn add_dae_secret(&mut self, dae_secret: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RadiusConf::VT_DAE_SECRET, dae_secret);
    }
    #[inline]
    pub fn add_dynamic_vlan(&mut self, dynamic_vlan: u8) {
        self.fbb_
            .push_slot::<u8>(RadiusConf::VT_DYNAMIC_VLAN, dynamic_vlan, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RadiusConfBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RadiusConfBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RadiusConf<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}
